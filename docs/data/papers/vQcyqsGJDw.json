{"id": "vQcyqsGJDw", "number": 21064, "cdate": 1758313339557, "mdate": 1763655815376, "content": {"title": "Sculpting Subspaces: Constrained Full Fine-Tuning in LLMs for Continual Learning", "abstract": "Continual learning in large language models (LLMs) is prone to catastrophic forgetting, where adapting to new tasks significantly degrades performance on previously learned ones. Existing parameter-efficient methods often limit model expressivity or introduce new parameters per task, creating scalability issues. To address these limitations, we introduce **Orthogonal Subspace Fine-Tuning (OSFT)**, a novel parameter-efficient approach for continual learning. OSFT leverages adaptive singular value decomposition (SVD) to dynamically identify and preserve critical, high-rank parameter subspaces that encode prior knowledge. All updates for new tasks are constrained to be strictly orthogonal to these preserved subspaces, which minimizes interference while maintaining a fixed parameter count and avoiding the need to store task-specific gradients. We extensively evaluate OSFT on standard continual learning benchmarks using both encoder-decoder (T5-Large) and decoder-only (LLaMA-2 7B, Mistral-7B) models across diverse tasks. Empirically, our method achieves a state-of-the-art trade-off between learnability and knowledge retention, dominating the Pareto frontier, with **up to 7\\% higher** average accuracy than recent baselines like O-LoRA, and **reduces forgetting to near-negligible levels**. It notably maintains the model's general linguistic capabilities, instruction-following, and safety throughout the learning process. OSFT provides a practical, theoretically grounded, and scalable solution that effectively balances model plasticity and knowledge retention for continual learning in LLMs.", "tldr": "We propose a constrained fine-tuning method for continual learning in LLMs using SVD and effective rank to guide updates in subspaces spanned by low singular vectors, significantly reducing catastrophic forgetting and outperforming SOTA methods.", "keywords": ["Continual Learning", "Parameter-Efficient Fine-Tuning", "Full Fine-Tuning", "Catastrophic Forgetting", "Singular Value Decomposition", "Geometric Constraints", "Orthogonal Subspaces", "Low-Rank Subspaces", "Constrained Optimization"], "primary_area": "foundation or frontier models, including LLMs", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/a65d68d7ffa33d21e8b2ff18cf9ed13405f6560d.pdf", "supplementary_material": ""}, "replies": [{"content": {"summary": {"value": "The paper proposes OSFT (Orthogonal Subspace Fine-Tuning), a continual learning method for LLMs that (i) performs per-layer SVD of weight matrices, (ii) treats the top singular directions as a high-rank subspace presumed to carry previously acquired knowledge, and freezes them, and (iii) constrains all parameter updates for new tasks to the orthogonal complement (low-rank subspace). To avoid a one-size-fits-all rank, the method uses an input–output cosine similarity proxy to adaptively determine, per layer, how many top singular directions to preserve. Implementation can be realized either by explicit gradient projection or by a reparameterization that freezes the high-rank factors and optimizes only the low-rank factors. The authors provide a second-order analysis suggesting a tighter bound on worst-case forgetting than both unconstrained full fine-tuning and fixed-rank projection, and report empirical improvements over strong orthogonal/low-rank baselines across multiple sequential learning benchmarks."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "- Conceptually transparent and practically implementable “stability–plasticity” mechanism.\nThe paper operationalizes “protecting prior knowledge” as a geometric constraint on update directions: disallow updates along top singular modes and permit updates only in their orthogonal complement. This aligns with the intuition that model behavior is most sensitive along dominant spectral directions while leaving substantial slack in the complementary subspace for learning. Importantly, the mechanism does not require rehearsal buffers or per-task parameter growth. Both explicit gradient projection and a reparameterized module (freezing high-rank, training low-rank) are described, making integration into standard PyTorch/PEFT pipelines straightforward.\n\n- Layer-wise adaptive capacity allocation that mitigates the brittleness of fixed-rank approaches.\nBy estimating a layer’s “knowledge-carrying importance” via input–output similarity and then allocating more preserved high-rank directions to important layers, the method avoids uniform rank settings that can either under-protect critical layers or overconstrain unimportant ones. This per-layer adaptivity is well-motivated for Transformers—whose layers differ in function—and empirically reduces sensitivity to rank choice while improving overall stability–plasticity trade-offs.\n\n- A coherent theory–practice loop.\nThe paper offers a second-order analysis yielding a hierarchy of forgetting bounds (adaptive projection < fixed-rank projection < unconstrained full fine-tuning) and leverages the widely observed empirical link between large singular directions and high-curvature/importance directions as a computationally feasible surrogate for direct curvature estimation. The result is a self-consistent narrative—curvature → dominant spectral directions → orthogonal update constraint—that ties mathematical justification to implementable proxies.\n\n- Reasonably broad empirical coverage with diagnostic ablations.\nEvaluations span both encoder–decoder and decoder-only architectures, short and long task sequences, and more comprehensive sequential scenarios, with comparisons to state-of-the-art orthogonal/low-rank baselines (e.g., O-LoRA–style methods). Ablations (e.g., removing orthogonal projection; reducing preserved rank) produce large and consistent degradations, highlighting that both the orthogonality constraint and the adaptive preservation rule are functionally essential. The fact that model size remains constant across tasks is also practically appealing for deployment."}, "weaknesses": {"value": "- Computational budget and fairness (stronger budget-controlled comparisons are needed).\nAlthough OSFT maintains constant model size across tasks, its per-task training still operates in the full parameter space under constraints, which can entail higher effective degrees of freedom and greater compute/time than small-parameter PEFT schemes (e.g., LoRA/adapters). The paper lacks strictly budget-matched comparisons (e.g., equal GPU-hours, equal training steps, equal hyperparameter search budgets) and energy/latency reporting. Without such controls, reported gains may partially reflect additional compute rather than methodological superiority. A detailed performance–cost table/curve would materially strengthen the claims.\n\n- Breadth of general capability and safety evaluations (evidence remains narrow).\nThe paper asserts that general abilities and alignment/safety are preserved after continual updates, yet the evaluation scope is limited relative to the breadth of LLM competencies (mathematical reasoning, code generation, tool use, long-context robustness, multilingual performance, jailbreak resistance, hallucination propensity, etc.). Stronger conclusions would require wider, multi-dimensional assessments with multi-seed mean±std and budget-controlled settings to rule out noise and tuning bias.\n\n- Limited coverage of recent open-source model families (e.g., Qwen3).\nExperiments primarily focus on T5-Large and LLaMA-2/7B-scale models. Given the rapid adoption of newer families—Qwen3, Llama-3, etc.—the method’s external validity would be clearer with systematic evaluations on these up-to-date backbones, ideally alongside the model-specific best practices for PEFT/CL provided by those communities."}, "questions": {"value": "- Stability of general capabilities: how can the evaluation scope and statistical rigor be strengthened?\nCould the authors expand to mathematics (e.g., GSM8K/MathBench), code (HumanEval/MBPP/Codeforces-style reasoning) and tool use (ReAct/ToolBench), and report multi-seed mean±std under compute-matched settings? Additionally, plotting capability drift curves across task order (before/after sequential updates) would offer a more granular view of the stability–plasticity dynamics.\n\n- SVD–curvature relationship: can the link be verified quantitatively and leveraged adaptively?\nThe approach relies on the empirical premise that top singular directions approximate high-curvature/importance directions. Could the authors, for representative layers, extract the leading Hessian/Fisher eigenvectors and measure principal angles to the top singular vectors? Further, could they compare “protect SVD-top vs protect Fisher-top vs a joint criterion,” and explore Fisher-weighted singular-value ranking or multi-criteria scoring to define the preserved subspace? Such analyses would more directly substantiate the curvature surrogate assumption and might yield an even more robust adaptive preservation rule."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 8}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "cPuuI07ncx", "forum": "vQcyqsGJDw", "replyto": "vQcyqsGJDw", "signatures": ["ICLR.cc/2026/Conference/Submission21064/Reviewer_zn3T"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission21064/Reviewer_zn3T"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission21064/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761704013344, "cdate": 1761704013344, "tmdate": 1762940636353, "mdate": 1762940636353, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"title": {"value": "Overall response and revision summary"}, "comment": {"value": "We thank all the reviewers for their thoughtful and constructive feedback. We have significantly improved clarity, provided additional experiments and baselines, and tried to address each concern raised. Detailed responses to reviewers are added as comments on OpenReview, outlining the key revisions and clarifications. All new or revised content in the updated manuscript is highlighted in green."}}, "id": "RgFmz67yTa", "forum": "vQcyqsGJDw", "replyto": "vQcyqsGJDw", "signatures": ["ICLR.cc/2026/Conference/Submission21064/Authors"], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission21064/Authors"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission21064/-/Official_Comment"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1763650883712, "cdate": 1763650883712, "tmdate": 1763652167720, "mdate": 1763652167720, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Comment", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The authors propose **Orthogonal Subspace Fine-Tuning (OSFT)** for continual learning. They utilize adaptive singular value decomposition (SVD) to dynamically identify and preserve critical, high-rank parameter subspaces. They first introduce *importance-guided allocation*, i.e., measuring each layer’s importance via input–output cosine similarity (where low-similarity layers are allocated more adaptive capacity). This determines importance scores, which, together with retention ratios, define the fraction of singular vectors to preserve per layer. The authors perform *adaptive subspace identification*, i.e., decomposing each layer via SVD to find critical components with a selected rank. Lastly, they apply *orthogonal gradient projection*, i.e., projecting gradients to be orthogonal to the critical subspaces. Concretely, they freeze high-rank components, and project the low-rank component's gradients to be orthogonal to the high-rank basis vectors.\n\nThey evaluate the method across two continual-learning benchmarks and more realistic TRACE benchmark, using encoder–decoder models (T5-Large) and decoder-only models (LLaMA-2-7B, Mistral-7B). They report average accuracy, forgetting measures, and retention of general capabilities and safety."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "The paper presents a thoughtful and well-motivated approach to preserving critical subspaces in continual learning.\n\n---\n\n- The paper includes computational analysis as well as theoretical justification.\n- A strong set of comparison methods is included.\n- A large number of datasets are used in the evaluation.\n- The related work section is generally good.\n- The hyperparameters (e.g., mrr, trr) appear to have sensible default values, and the authors provide practical guidance for tuning.\n- The evaluation follows standard protocols, averaging results over three independent runs with randomly permuted task sequences."}, "weaknesses": {"value": "### **1. Methodological Clarity & Design**\n\n- Data from task (t) is used when evaluating layer importance for task (t+1).\n- The methods section lacks a clear, cohesive narrative.\n- The method does not appear particularly parameter-efficient relative to other PEFT approaches.\n- The claim that the method “retains and transfers knowledge across tasks” may be too strong; empirical evidence for *transfer* should be clarified.\n\n---\n\n### **2. Missing Definitions & Introductions**\n\n- SLERP, TIES, and TRACE are not properly introduced before being used in comparisons.\n- Figure 1 uses terms (TRACE, average backward transfer, forgetting) without definition.\n- Cosine similarity is referenced conceptually but never explicitly visualized or explained in the results.\n\n---\n\n### **3. Comparisons & Baselines**\n\n- Prior work [1] shows that full fine-tuning forgets more; therefore, full fine-tuned baselines may not be appropriate, and stronger PEFT baselines should be included.\n\n---\n\n### **4. Presentation & Figure Issues**\n\n- Several plots require cleanup and clarifications; Figures 1 and 2 are presented out of order.\n    - Figure 2 is difficult to interpret (e.g., unclear connection between “layer 2 = layer ℓ”, too many elements, cosine similarity not referenced).\n\n---\n\n### **5. Organization & Structure**\n\n- Section 3.7 duplicates material that would be more appropriately placed in the related work section.\n\n[1] LoRA Learns Less and Forgets Less. (2024) Dan Biderman and Jacob Portes and Jose Javier Gonzalez Ortiz and Mansheej Paul and Philip Greengard and Connor Jennings and Daniel King and Sam Havens and Vitaliy Chiley and Jonathan Frankle and Cody Blakeney and John P. Cunningham"}, "questions": {"value": "1. O-LoRA appears to use significantly fewer parameters, and its trade-off curve leads to a wider curve which seems desirable. Could you comment on that? In Figure 1 - why change the rank in O-LoRA, and not the strength of regularization? Similarly, for replay-based baselines, why the learning rate is changed and the amount of data?\n2. The related work section does not discuss MiLoRA [1] and PiSSA [2], which seems like a significant oversight - can you include them, also in the experimental section? Especially MiLoRA seems like a crucial method.\n3. Can the authors explain what happens when the number of tasks grows large? How does that affect required SVD rank, is there a threshold before capacity becomes an issue? Can the authors relate the SVD subspace of task 0 and task 5, for example? How is interference with early tasks prevented over time?\n4. Can the authors further motivate the choice of a *weight-space* approach versus a *function-space* (activation-based) approach?\n5. The cited empirical findings (Sharma et al., 2023; Li et al., 2025) show that layers with higher input–output similarity exhibit greater Hessian curvature. Could the authors expand on this relationship?\n6. Why do PerTaskFT and MTL report “N/A” for the BT metric?\n7. Page 6 L297 - what is the reference for that?\n\n[1] MiLoRA: Harnessing Minor Singular Components for Parameter-Efficient LLM Finetuning. (2025) Hanqing Wang and Yixia Li and Shuo Wang and Guanhua Chen and Yun Chen\n\n[2] PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models. (2024) Fanxu Meng and Zhaohui Wang and Muhan Zhang"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "lKCL3YiayO", "forum": "vQcyqsGJDw", "replyto": "vQcyqsGJDw", "signatures": ["ICLR.cc/2026/Conference/Submission21064/Reviewer_uSxf"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission21064/Reviewer_uSxf"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission21064/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761743827763, "cdate": 1761743827763, "tmdate": 1762940635957, "mdate": 1762940635957, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The paper proposes OSFT for continual learning in large language models. OSFT first performs SVD on each weight matrix to identify high‑rank directions that encode prior knowledge and low‑rank directions that can be safely reused. It computes a layer‑importance score and retains more singular vectors in crucial layers, allocating more adaptable capacity to less crucial ones. During training, OSFT projects gradients orthogonally to the preserved subspaces. The authors support this design with a theoretical analysis linking forgetting to Hessian curvature and with the use of top singular vectors as a practical proxy for high‑curvature directions."}, "soundness": {"value": 2}, "presentation": {"value": 3}, "contribution": {"value": 2}, "strengths": {"value": "1. The paper is well-structured and easy to read.\n2. The paper includes experiments on traditional benchmarks."}, "weaknesses": {"value": "1. Gradient projection onto an orthogonal complement is a known CL idea. OSFT’s twist is: project in weight space using SVD‑identified directions, not activation space; and make the preserved rank per layer adaptive. The layer‑importance measure is explicitly inspired by AdaSVD, and the theoretical appeal of preserving top singular directions is attributed to an external empirical correlation. This strengthens the sense of a careful integration of existing ideas more than a conceptual break‑through.\n2. The proxy that top singular vectors ≈ high‑curvature/Hessian directions is justified by citing external robust correlation, not by measurements on the authors’ own T5/LLaMA runs. The paper does not report a Hessian–SVD alignment check on its trained models. \n3. The proposed method activates more parameters than O-LoRA but fewer than full fine-tuning. By doing so, it improves performance compared to O-LoRA while mitigating forgetting relative to full fine-tuning. This suggests that the method effectively identifies an appropriate number of parameters to utilize. If there exist experiments that adjust the number of active parameters without applying the proposed method, it would help clarify the unique contribution of the proposed approach.\n4. The paper cites Inflora (Liang & Li, 2024) and LoTA (Panda et al., 2024). LoTA is only compared in an appendix two‑task transfer, not in the main CL sequences; Inflora is not benchmarked at all, despite being specifically about interference‑free low‑rank continual learning. This weakens the empirical positioning.\n5. Figure 1 notes “crucial hyper‑parameters varied for each method,” but the ranges, tuning protocol, and compute budget per method aren’t given. \n6. It’s unclear whether baselines received equivalent tuning or comparable trainable‑parameter fractions—particularly important because OSFT is shown at 56% while LoRA baselines are 1–3%. Claims of frontier domination are therefore budget‑confounded."}, "questions": {"value": "1. Is there a reason why authors did not measure forgetting per task and forward transfer with comparison methods (A.11 partly helps, but no aggregate forgetting stats are given)?\n2. Existing LoRA-based methods do not appear to suffer from performance degradation as severe as that observed with the proposed method on the GSM8K benchmark. In this regard, is there a particular reason why experiments with LoRA-based approaches were not conducted?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "Q1H9rTPnKF", "forum": "vQcyqsGJDw", "replyto": "vQcyqsGJDw", "signatures": ["ICLR.cc/2026/Conference/Submission21064/Reviewer_oGvj"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission21064/Reviewer_oGvj"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission21064/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761896584809, "cdate": 1761896584809, "tmdate": 1762940635577, "mdate": 1762940635577, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper proposed the orthogonal subspace fine-tuning (OSFT) method in continual learning. It performs SVD on each layer and utilizes the cosine similarity between input activations and its linear outputs to determine high-rank subspace and low-rank subspace of each layer weight. To preserve the important previous knowledge, OSFT orthogonally updates in low-rank subspaces by projecting gradients onto low-rank subspaces. Experimental results on continual learning benchmarks show the effectiveness of OSFT."}, "soundness": {"value": 2}, "presentation": {"value": 2}, "contribution": {"value": 2}, "strengths": {"value": "1. The proposed OSFT considers the difference between high-rank and low-rank subspaces to achieve orthogonal gradient updates in directions which are orthogonal to previous knowledge.\n\n2. The proposed OSFT adaptively allocates parameter budgets across layers, rather than treating them equally, which balances stability and plasticity across the network based on the role of each layer."}, "weaknesses": {"value": "1. The computation cost of OSFT would be huge since it needs to compute full-dimensional gradients during training, and then projects full-dimensional gradients to low-rank parameter subspaces obtained by computing SVD on each layer weight.\n\n2. The motivation of the design for OSFT is not well constructed and discussed. For example, authors only cited one paper without any discussion to support the choice of cosine similarity. Since this similarity choice should be one contribution of this paper, which connects with the determination of low-rank subspace, it should be discussed and evaluated carefully.\n\n\n3. Experiments lack recent parameter-efficient continual learning baselines, SAPT [1], InfLoRA [2], and CorDA [3]. Also, Table 1 does not show the performance on each task order, which is important to show the robustness of the proposed method, and Table 8 in the appendix only shows order 1. Besides, it’s not clear about the task order in Table 3.\n\n[1] SAPT: A shared attention framework for parameter-efficient continual learning of large language models, ACL2024.\n\n[2] InfLoRA: Interference-Free Low-Rank Adaptation for Continual Learning, CVPR2024.\n\n[3] CorDA: Context-Oriented Decomposition Adaptation of Large Language Models for Task-Aware Parameter-Efficient Fine-tuning, NeurIPS 2024.\n\n\n4. The ablation study disappears in the experiment section. In Eq (3), mrr and trr should be evaluated with different values to show the performance or robustness of OSFT. The authors just mentioned “ablation studies show that while performance degrades significantly if retention is too aggressive”, but authors do not provide these results."}, "questions": {"value": "1. In this paper, OSFT updates on the subspaces consisting of smaller singular values of the weights, but in CorDA [1] and SVD-LLM [2], both works utilize the input information along with the weights to compute SVD for obtaining the subspaces of smaller/larger singular values. Especially, SVD-LLM states that “truncating smaller singular values in SVD could lead to significant compression loss”, which means there is no linear relationship between performance and singular values obtained only by weight itself. Can authors explain the OSFT’s differences from the conclusions of these two papers?\n\n[1] CorDA: Context-Oriented Decomposition Adaptation of Large Language Models for Task-Aware Parameter-Efficient Fine-tuning, NeurIPS 2024.\n\n[2] SVD-LLM: Truncation-aware Singular Value Decomposition for Large Language Model Compression, ICLR 2025.\n\n\n2. Can authors compare the experimental performance of OSFT with SAPT, InfLoRA, or CorDA(Knowledge-preserved adaptation version)?\n\n\n3. In line 15 in Algorithm 1, OSFT “computes gradients for trainable SVD components”. What’s the interval step of computing SVD components? Does OSFT compute SVD at each training step? If so, the computation and training time of OSFT is significantly large, which is not efficient and not practical. Can authors compare the training time and memory cost of OSFT with O-LoRA, SAPT, or InfLoRA?\n\n4. Compared to LoRA-based methods, OSFT needs to compute the gradients of full-dimensional weights, which is very expensive for LLMs. Although the paper title is about “constrained full fine-tuning in LLMs”, FFT is costly for LLMs in downstream tasks. Also, if OSFT belongs to FFT in LLMs, then experiments may need to be redesigned since the current used benchmarks, like GLUE and SuperGLUE, are sampled with 1000 training samples, which are too small for FFT.\n\n5. What’s the choice of effective rank of OSFT in Figure 1? Can authors clarify the experimental settings of OSFT in Figure 1? It’s confusing about how to obtain the three different dots of OSFT in Figure 1.\n\n6. The paper does not discuss in detail why to choose cosine similarity to compute each layer’s importance. Since there are other useful measurements, for example, centered kernel alignment (CKA) [1] measures the similarity between the intermediate activations of two models at each layer. Can authors discuss the difference between these similarities?\n\n[1]  Similarity of neural network representations revisited, ICML 2019."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "TRcLc6K8Wr", "forum": "vQcyqsGJDw", "replyto": "vQcyqsGJDw", "signatures": ["ICLR.cc/2026/Conference/Submission21064/Reviewer_5uQ5"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission21064/Reviewer_5uQ5"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission21064/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761922462990, "cdate": 1761922462990, "tmdate": 1762940634602, "mdate": 1762940634602, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}