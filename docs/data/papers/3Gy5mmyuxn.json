{"id": "3Gy5mmyuxn", "number": 17067, "cdate": 1758271761990, "mdate": 1759897200686, "content": {"title": "ROC-n-reroll: How verifier imperfection affects test-time scaling", "abstract": "Test-time scaling aims to improve language model performance by leveraging additional compute during inference. \nMany works have empirically studied techniques such as Best-of-N (BoN) and Rejection Sampling (RS) that make use of a verifier to enable test-time scaling. However, to date there is little theoretical understanding of how verifier *imperfection* affects performance — a gap we address in this work. Specifically, we prove that the instance-level accuracy of these methods is precisely characterized by the geometry of the verifier’s ROC curve. Our theory has two important takeaways, confirmed by experiments with Qwen and LLama models on GSM8K and MATH500. First, RS outperforms BoN for fixed compute, while both methods converge to the same accuracy in the infinite-compute limit. Second, it is generally impossible to predict the high-compute performance of either method based on observations in the low-compute regime.", "tldr": "", "keywords": ["test-time scaling", "inference-time scaling", "best of n", "theory", "data quality"], "primary_area": "learning theory", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/20be18a6bc2b05fe3b6cf22205cca94724ff52f3.pdf", "supplementary_material": ""}, "replies": [{"content": {"summary": {"value": "This paper provides a theoretical and empirical analysis of how verifier imperfections influence test-time scaling methods such as Best-of-N (BoN) and Rejection Sampling (RS). It shows that the accuracy of these methods is determined by the geometry of the verifier’s ROC curve, rather than by specific implementation details. It proves that RS outperforms BoN for fixed compute budgets and that both converge to the same accuracy as compute increases. The authors validate these findings empirically using Qwen and LLaMA models on GSM8K and MATH500, confirming that high-compute performance cannot be extrapolated from low-compute behavior."}, "soundness": {"value": 2}, "presentation": {"value": 2}, "contribution": {"value": 3}, "strengths": {"value": "1. The paper provides a theoretical understanding for resampling-based inference-time compute scaling, a timely and important topic in the era.\n2. The analysis connects verifier imperfection to scaling behavior via the ROC curve. The link between ROC geometry and compute-performance scaling provides a unifying lens to reason about imperfect verifiers.\n3. The paper is well-motivated, and the structure is clear."}, "weaknesses": {"value": "1. The experiments only focus on two mathematical reasoning datasets (GSM8K and MATH500), where numeric ground truths simplify verification. I wonder whether the theoretical insights generalize to other reasoning datasets (e.g., commonsense reasoning) or open-ended generation (e.g., summarization, dialogue) or code generation.\n2. Although the paper briefly discusses connections to RL (Appendix C.1), it doesn’t empirically test and validate these hypotheses. A comparison to small-scale RL fine-tuning (e.g., DPO, PPO) would strengthen the generalization of this argument.\n3. The empirical performance curves in Figure 1 are only shown for a hand-picked example (test question 58).\n4. The paper provides no actionable method to improve verifiers or scaling strategies — it only diagnoses why scaling may fail. Especially, one of the paper's findings in the abstract is that it is \"generally impossible to predict the high-compute performance\" from low-compute observations, which is a negative result without constructive guidance on how to solve this problem."}, "questions": {"value": "See in weaknesses."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 2}, "code_of_conduct": {"value": "Yes"}}, "id": "qB6xrcKpst", "forum": "3Gy5mmyuxn", "replyto": "3Gy5mmyuxn", "signatures": ["ICLR.cc/2026/Conference/Submission17067/Reviewer_WUvv"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission17067/Reviewer_WUvv"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission17067/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761966301166, "cdate": 1761966301166, "tmdate": 1762927077732, "mdate": 1762927077732, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This work investigates the performance of two LLM test-time scaling methods in scenarios with an imperfect verifier:  \n- Rejection Sampling (RS): generates responses sequentially until one passes verification.  \n- Best-of-N (BoN): generates N responses in parallel and selects the one with the highest verification score.  \n\nWithin a formal statistical framework, the authors rigorously show that the accuracy of either method for solving a single query under a fixed compute budget is determined precisely by the ROC curve corresponding to the generator and verifier.\n  \nHigh-level takeaways from the analysis include:  \n1. RS outperforms BoN under fixed compute (assuming the ROC curve is concave), although both converge to the same accuracy when compute is unlimited.  \n2. For either method, high-compute accuracy cannot be reliably predicted from low-compute performance.  \n\nTheoretical findings are validated through experiments, lending further support to the results."}, "soundness": {"value": 4}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "This paper presents a solid and well-executed contribution to the LLM research community, even though it does not introduce new algorithms. The theoretical analysis of RS and BoN is thorough and rigorous, providing fresh insights into their behaviors when given *imperfect verifiers*. The work offers practical takeaways for researchers and practitioners considering repeated sampling approaches.  \n\n*(Disclaimer: Some technical content extends beyond my core expertise, and thus I have not verified the correctness of all proofs in detail.)*"}, "weaknesses": {"value": "I don't see major weaknesses in this work, assuming that the theoretical analyses are correct.\n\n\nSome suggestions:\n\n- The takeaway message \"RS outperforms BoN under fixed compute\" requires the assumption that the ROC curve (for the particular query under consideration) is concave, according to Proposition 5. I think this assumption should be stated more explicitly in the abstract and introduction, otherwise the takeaway message alone could be slightly misleading. \nIn reality, there is no guarantee *a priori* that the ROC curve should be concave.\n\n- The proof for BoN's limit accuracy in Theorem 1 (which equals that of RS in Proposition 2) is quite complicated.\nOn the other hand, we might think of (or approximate) BoN in the infinite-compute limit as (1) generating many samples, (2) keeping the samples whose scores exceed $1 - \\delta$ (with $\\delta \\rightarrow 0$), (3) breaking ties and picking one of the high-score samples randomly.\nIn this case, BoN's accuracy is effectively the posterior probability that a generated sample is correct, conditioned on its score exceeding $1 - \\delta$.\nThis probability can be easily derived by the Bayes rule, and doesn't fundamentally differ from the analysis for RS.\nI wonder how far from rigor this analysis is, and whether it could offer some intuitions about Theorem 1 and the takeaway message that BoN and RS reach the same accuracy with infinite samples.\n\n- Use a notation other than $\\pi$ (Line 137) to avoid confusion with the mathematical constant $\\pi \\approx 3.14$.  \n\n- Line 373, \"Comparing with Proposition 1\": should be \"Proposition 2\".\n\n- Include and discuss more related works, which could situate this paper more clearly in the literature on LLM test-time scaling.\nExamples include [1, 2, 3] that provide theoretical analyses for different test-time scaling methods, and [4] that also investigates the limits of LLM repeated sampling when given imperfect verifiers (albeit more empirically).\n\n[1] Are More LLM Calls All You Need? Towards Scaling Laws of Compound Inference Systems (NeurIPS 2024)\n\n[2] Provable Scaling Laws for the Test-Time Compute of Large Language Models (NeurIPS 2025)\n\n[3] When More is Less: Understanding Chain-of-Thought Length in LLMs (ICLR 2025 Workshop)\n\n[4] Inference Scaling fLaws: The Limits of LLM Resampling with Imperfect Verifiers (arXiv 2024)"}, "questions": {"value": "See \"weaknesses\" above."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 8}, "confidence": {"value": 2}, "code_of_conduct": {"value": "Yes"}}, "id": "zI4p9KIaxw", "forum": "3Gy5mmyuxn", "replyto": "3Gy5mmyuxn", "signatures": ["ICLR.cc/2026/Conference/Submission17067/Reviewer_NcCh"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission17067/Reviewer_NcCh"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission17067/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761990281925, "cdate": 1761990281925, "tmdate": 1762927077416, "mdate": 1762927077416, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper studies rejection sampling and best-of-N sampling for LLMs with imperfect verifiers. The core idea is that, for a fixed sampling budget, the performance of both methods is determined by the verifier's ROC curve and the generator's base accuracy. The authors show this theoretically and provide empirical validation on math datasets."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 2}, "strengths": {"value": "1. Interesting problem, clean formalization, and clear scope that focuses on RS and BoN.\n2. The result that RS outperforms BoN with fixed average compute seems useful in practice.\n3. Empirical experiments show consistent results with theory's prediction."}, "weaknesses": {"value": "1. **Limited evaluation domain**: Can the authors also consider other benchmark categories such as coding or more general QA? This is critical for evaluation whether the conclusion generalizes.\n2. **Compute metric mismatch and missing hybrid method**\n\t- The compute metric for RS is defined as an expectation, while the compute metric for BoN is defined as the deterministic N. The stopping time of  RS creates variance but the analysis optimize only the mean. Also, the experiments on MATH500 and GSM8K has a cap at 25 (line 448), which changes the RS distribution in a way not covered by the theory.\n\t- Taking a step further, it feels natural to consider a hybrid approach where BoN early-stops if a certain score threshold is reached (or RS early stops if a certain N is reached). Although the authors mention this as future work, I believe that this is a baseline much more realistic than RS without stopping."}, "questions": {"value": "- Can you verify the results on more diverse benchmarks?\n- How will a hybrid method change your conclusions? Will this hybrid method outperform both RS and BoN? Could you test it empirically?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 2}, "code_of_conduct": {"value": "Yes"}}, "id": "4wPVbfwOWx", "forum": "3Gy5mmyuxn", "replyto": "3Gy5mmyuxn", "signatures": ["ICLR.cc/2026/Conference/Submission17067/Reviewer_RwZD"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission17067/Reviewer_RwZD"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission17067/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762074342066, "cdate": 1762074342066, "tmdate": 1762927077156, "mdate": 1762927077156, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper presents a timely study on how imperfections in a verifier affect the performance of test-time scaling, where the goal is to improve accuracy by spending more compute at inference time. The authors analyze two commonly used techniques: rejection sampling (RS) and Best-of-N (BoN). They show that the performance of both methods is fully determined by the geometry of the verifier’s ROC curve. For RS, they prove that performance in the low-compute and high-compute regimes depends on the local geometry of the ROC curve — specifically, how the ROC behaves near the operating points corresponding to large and small false-positive rates (FPR). In the high-compute regime, accuracy is governed by the slope of the ROC near FPR $\\to$ 0. For BoN, performance depends on global ROC properties.\n\nTheir theoretical results, supported by experiments, show that RS is more compute-efficient than BoN in the finite compute regime, while both methods converge to the same asymptotic accuracy as compute goes to infinity. A key insight is that test-time scaling cannot be extrapolated: low-compute performance does not predict high-compute performance unless one knows the ROC geometry."}, "soundness": {"value": 3}, "presentation": {"value": 2}, "contribution": {"value": 3}, "strengths": {"value": "- One of the main strengths of this paper is that the authors present a simple and interpretable mathematical framework for analyzing how verifier imperfections impact the effectiveness of test-time scaling. Their formulation leverages classical concepts from statistical learning theory (e.g., ROC curves, true/false positive rates), providing a clean lens through which to reason about the verifier. This contribution is valuable because it connects modern LLM sampling practices with well-established theoretical tools, which may inspire clearer definitions and analysis in future research.\n\n- Another strength is that the theoretical predictions align well with empirical results. For example, in Figure 3, the experiments on LLaMA models show the expected behavior: RS outperforms BoN under finite compute budgets, consistent with the theoretical claim that RS is more compute-efficient.\n\n- Overall, the paper offers practical guidance on how to deploy test-time scaling methods when compute is constrained. It clarifies when additional sampling is worthwhile, and when verifier limitations make further compute ineffective."}, "weaknesses": {"value": "- One weakness of this paper is its clarity / organization. I think the clarity can be significantly improved by including a table of notations in the main manuscript. On the first pass, it was difficult to follow the derivations because I had to look back to recall the notation.\n\n- The theory models correctness as a binary variable (either correct or incorrect). This abstraction simplifies analysis, but it may limit applicability in settings where output quality is continuous or graded, e.g., in RL where partial correctness matters. It is unclear how the theoretical results extend to cases with non-binary reward structures or scalar score models, which are common in modern LLM evaluation and verification frameworks."}, "questions": {"value": "Here are both questions and comments:\n\n- This question might be a bit more abstract: the weakness stated above leads me to wonder whether compute could be defined differently in this setting. In the paper, compute is measured as the total number of generations. However, one could instead measure compute as the total number of tokens generated. If compute were defined in terms of token usage rather than completions, the relative advantage of RS could change. In particular, BoN may appear more favorable under a token-based compute budget, since it generates a fixed number of completions of comparable length, whereas RS may generate highly variable amounts of text before accepting a sample. Have the authors thought about these directions, if this is not sound I am happy to discuss.\n\n- There is an iid assumption on the samples generated for BoN; is this pivotal in the proofs? I'm not sure this can be met in practice so it leaves me wondering if this is a drawback at all, or it doesn't matter and is just a definition.\n\n-  I guess $\\tau$ should be in [0, 1] in line 141\n\n- It feels confusing to me to say \"let the score $f$ to be fixed\"; this sounds like the score is fixed and not the verifier. Perhaps calling it the verifier as done in line 301 is better.\n\n- Does the theory depend at all if $h_F$ is not unique, i.e., there are multiple solutions to Equation (1)?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "yTUDv158kM", "forum": "3Gy5mmyuxn", "replyto": "3Gy5mmyuxn", "signatures": ["ICLR.cc/2026/Conference/Submission17067/Reviewer_dsXu"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission17067/Reviewer_dsXu"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission17067/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762220210967, "cdate": 1762220210967, "tmdate": 1762927076809, "mdate": 1762927076809, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}