{"id": "mrafO7aTYj", "number": 17517, "cdate": 1758277077100, "mdate": 1759897169897, "content": {"title": "LoRAGen: Structure-Aware Weight Space Learning for LoRA Generation", "abstract": "The widespread adoption of Low-Rank Adaptation (LoRA) for efficient fine-tuning of large language models has created demand for scalable parameter generation methods that can synthesize adaptation weights directly from task descriptions, avoiding costly task-specific training. We present LoRAGen, a structure-aware method for generating LoRA parameters from natural language descriptions. Through empirical analysis of LoRA libraries, we identify two key structural properties of LoRA parameter spaces: non-uniqueness of low-rank decomposition and heterogeneous weight distributions across network modules. These properties necessitate specialized parameter generation methods rather than general weight space learning approaches. LoRAGen employs a latent diffusion model with two innovations: weight-space supervision on full adaptation matrices to handle decomposition non-uniqueness, and a module-aware Mix-of-Experts decoder that adapts to module-specific weight distributions. Experiments show LoRAGen achieves 96.0\\% performance relative to task-specific LoRAs on FLAN-T5-large and 72.7\\% on Gemma-2-2B-Instruct for in-distribution tasks, while obtaining 40.2\\% on zero-shot generation across unseen tasks—surpassing baselines by nearly 5\\%. Our work establishes the first structure-aware approach to LoRA generation with insights into adaptation weight space geometry.", "tldr": "LoRAGen is the first structure-aware method for generating LoRA parameters from natural language by addressing the unique geometric properties of low-rank adaptation spaces.", "keywords": ["Weight space learning", "hypernetworks", "LoRA", "latent diffusion"], "primary_area": "generative models", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/6198c08ce1c52882cf0c6845dbab6d46dc2542fc.pdf", "supplementary_material": ""}, "replies": [{"content": {"summary": {"value": "This paper proposes LoRAGen, a structure-aware framework for generating LoRA adapters from natural language, addressing the need for scalable and efficient model customization. The methodology is divided into two stages:\nStage 1: Learning a Structured LoRA Latent Space. A LoRA weight autoencoder is trained to map adapter weights to and from a latent space. Its key contribution is a module-aware Mixture-of-Experts (MoE) decoder, where different experts specialize in generating weights for different parts of the network architecture (e.g., attention vs. feed-forward layers). To overcome the issue that multiple low-rank matrices can produce the same adapter, training is supervised directly on the full adapter matrix, ensuring a more robust and meaningful latent space.\nStage 2: Text-Conditioned Latent Generation. A diffusion model is trained as a conditional prior over the learned latent space. At inference time, this model takes a natural language task description, encodes it, and generates a corresponding latent vector, which is then decoded into a full set of LoRA weights by the frozen decoder from Stage 1.\nThe primary contributions are the novel module-aware architecture for weight generation, the robust adapter-level supervision strategy, and the demonstration of strong zero-shot performance, which significantly outperforms existing baselines."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 2}, "strengths": {"value": "**Originality**\n\nThe originality of this work extends beyond just using a Mixture-of-Experts decoder. Its primary innovation lies in designing a module-aware MoE decoder specifically tailored to the structural properties of Transformer networks. Rather than using a monolithic decoder, this approach allows different experts to specialize in generating weights for distinct components (e.g., attention vs. feed-forward layers), which is a novel and highly effective concept. Furthermore, the paper introduces a unique adapter-level supervision strategy (using direction and spectral losses) to directly address the ambiguity of low-rank matrix factorization—a subtle but critical problem that previous methods have largely overlooked.\n\n**Quality**\n\nThe paper demonstrates high quality through its rigorous methodology and strong empirical evidence. The entire approach is well-grounded, with its core design principles directly motivated by clear empirical analysis of the LoRA weight space. The experimental validation is comprehensive and convincing, using multiple model architectures and strong baselines. The inclusion of a thorough ablation study, which isolates the contribution of each key component, further attests to the quality and soundness of the research.\n\n**Clarity**\n\nThe paper is written with exceptional clarity. The authors do an excellent job of building a logical narrative, starting with two core empirical observations, proposing solutions directly tailored to them, and then validating these solutions through experimentation. Complex concepts are broken down and explained in a way that is easy to follow, making the paper highly accessible despite its technical depth.\n\n**Strengths**\n\n**A Novel and Robust Generation Framework:** The paper significantly improves upon previous weight generation methods by introducing a more robust and structure-aware framework. The combination of the module-aware MoE decoder and adapter-level supervision provides a more principled way to learn the geometry of the LoRA weight space.\n\n**Principled Design Grounded in Strong Empirical Analysis:** The method isn't just a collection of techniques; it's a carefully designed solution based on a solid analysis of the problem space. This analytical rigor is a key strength and provides a strong foundation for the paper's claims.\n\n**Comprehensive and Convincing Empirical Validation:** The experiments are a major strength. The method achieves performance on par with, or even outperforming, task-specific LoRAs in some cases. Crucially, it demonstrates excellent generalization in both in-distribution and challenging zero-shot (out-of-distribution) settings, proving that it learns a meaningful mapping from language to weights rather than just memorizing trained adapters."}, "weaknesses": {"value": "**Scalability.**\nEvidence is limited to FLAN-T5-Large (~780M) and Gemma-2-2B. The method’s practical value at the scales where LoRA matters most (7B–70B+) is not demonstrated; compute, memory footprint, and stability characteristics at those sizes remain unclear.\n\n**Baselines and citation coverage.**\nThe evaluation focuses on diffusion-based generators while omitting recent non-diffusion prompt-to-LoRA approaches that also leverage pretrained knowledge, notably **Drag-and-Drop LLMs** and **LoRA-Gen**. This gap weakens novelty positioning and makes robustness claims harder to interpret relative to the broader literature.\n[1] *Drag-and-Drop LLMs: Zero-Shot Prompt-to-Weights*\n[2] *LoRA-Gen: Specializing Large Language Model via Online LoRA Generation*\n\n**Reproducibility and configuration transparency.**\nKey implementation details are not fully specified in the paper: the autoencoder’s exact topology, latent dimensionalities, MoE settings (E, top-K, routing temperature), per-module head parameterization, training schedules for both stages, and per-module LoRA ranks. Although code is provided, the manuscript itself lacks a consolidated description of these hyperparameters, limiting reproducibility from the text alone."}, "questions": {"value": "See weaknesses\n\n* **Why diffusion (vs other generative priors)?**\n  What concrete gains do you observe from a diffusion prior over simpler/cheaper alternatives (e.g., MLP/linear prior, VAE, normalizing flows, consistency/CM/rectified flow) on the *same latent space*?\n\n* **Sampling cost and scaling to larger adapters.**\n  Diffusion can be slow when sampling many adapter locations for deeper network. What is the end-to-end latency per full adapter set, and how does it scale with (i) number of LoRA locations and (ii) LoRA rank (r)?  If LoRA rank or the number of locations increases, does the autoencoder need redesign (latent size (d_z), decoder depth/width), or does performance remain stable?\n\n* **On missing baselines (Drag-and-Drop).**\n  Could you clarify why **Drag-and-Drop LLMs (prompt→weights hypernetwork)** was not included in benchmarks? Was this due to incompatibility, unavailable code, or scope? Given its direct relevance, a brief comparison or discussion of expected differences would help position your contribution.\n\n* **Decoder architecture/topology details.**\n  Please specify the module-aware MoE decoder precisely: number of experts (E), top-(K), shared vs per-module expert pools, router temperature, load-balancing objective, structural embeddings (module/layer dims), expert MLP widths/depths, normalization/activation/residual scheme, and per-module head parameterization (predicting full (\\Delta W) vs low-rank factors). A parameter-count and FLOPs breakdown per component would also clarify capacity vs. performance."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 5}, "code_of_conduct": {"value": "Yes"}}, "id": "OSsnJmbVE2", "forum": "mrafO7aTYj", "replyto": "mrafO7aTYj", "signatures": ["ICLR.cc/2026/Conference/Submission17517/Reviewer_mT9U"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission17517/Reviewer_mT9U"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission17517/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761560383695, "cdate": 1761560383695, "tmdate": 1762927397378, "mdate": 1762927397378, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "In this paper, the authors proposed LoRAGen, a structure-aware method that directly synthesizes LoRA parameters from natural language descriptions, to address a critical limitation of traditional LoRA workflows: the need for costly, task-specific training to generate LoRA parameters. LoRAGen can eliminate the need for task-specific data collection and training and is grounded in two key empirical observations about LoRA weight spaces."}, "soundness": {"value": 3}, "presentation": {"value": 2}, "contribution": {"value": 4}, "strengths": {"value": "1. The motivation of this paper is strong. It provides two observations to inspire the method.\n\n2. LoRAGen generates LoRA parameters directly from task descriptions, bypassing the need for task-specific data collection, annotation, and training.\n\n3. LoRAGen tackles LoRA parameter generation from two key properties of LoRA spaces: 1. the non-uniqueness of Low-rank decomposition and the heterogeneous weight distributions across modules.\n\n4. The empirical results are promising."}, "weaknesses": {"value": "1. The writing should be improved. For example, in Line 189, “the the cosine” => “the cosine”. In Line 188 “the adapter similarity similarity” => “the adapter similarity”\n\n2. For decoder-only architecture LLMs, the authors did not present weight distribution analysis.\n\n3. The experiments are only conducted on two small models (FLAN-T5-large and Gemma-2-2B). The authors should involve more popular LLMs, like Qwen3-8B and Llama2-7B, to make the empirical findings more convincing."}, "questions": {"value": "Please see Weaknesses."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 8}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "bjasYy10JJ", "forum": "mrafO7aTYj", "replyto": "mrafO7aTYj", "signatures": ["ICLR.cc/2026/Conference/Submission17517/Reviewer_6LiF"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission17517/Reviewer_6LiF"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission17517/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761755068510, "cdate": 1761755068510, "tmdate": 1762927396976, "mdate": 1762927396976, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The paper tries to directly predict LoRA adaptation weights from fine-tuning task descriptions with a DiT. With empirical findings that $\\Delta W$ correlates with task but not $A$ or $B$, and weights at different layers have different spectral entropy, the model is supervised by $\\Delta W$ and conditioned on the layer position."}, "soundness": {"value": 1}, "presentation": {"value": 1}, "contribution": {"value": 2}, "strengths": {"value": "An interesting exploration of weight space learning is presented."}, "weaknesses": {"value": "The empirical observations on which the assumption is made are unclear.  \nThe experiment is only carried out on a specific base model with concerns about cross-model generalization.  \nThe presentation is not very clear."}, "questions": {"value": "The meaning of Fig 1 (Left) is quite unclear, and the explanation in L184-187 is ambiguous. \"Similarity\" is something to be calculated in pairs, but the text doesn't really make it clear. What is the \"representative task\"? I assume that the authors compute the similarity between 112 other tasks and a single \"representative task\", i.e. duorc_gqba. Why was this task selected? Then to what extent they are correlated? Is the rho in the Figure Spearman's coefficient? Please state that more explicitly. From the figure I can't really see the correlation clearly, possibly because the two series are at quite different scales; possibly separating the (A, B) and $\\Delta W$ series into two figures will make it clearer. Particularly, the correlation looks dominated by certain samples with the largest task similarity; then are the observations applicable to other tasks? Also, $\\Delta W$ is not unique either. What will happen if you collect more samples per task?\n\nDiscussions on empirical observations are repeated in page 2 and page 4, and it's difficult to check Fig 1 when reading page 4. I suggest only briefly mentioning the empirical conclusions in the Intro part and moving Fig 1 to page 4.\n\nL357: What is \"element-wise averaged LoRA\"?\n\nL372-373: How is the model applied to a decoder-only base model? I assume that the model is trained on FLAN-T5, including the module/layer embeddings.\n\nAlso, the target model Gemma-2-2B-Instruct itself can already get good performance on many tasks. Hence I have concerns about the cross-model generalization. I think this is critical for the practical use of this series of methods, as training hypernetwork is expensive, LoRA-tuning itself is already cheap, and there is still a considerable performance gap between generated and trained LoRA.\n\nI also have doubts about FLAN-T5's low performance on the benchmarks. Isn't FLAN-T5 already trained on those tasks?\n \n\nL135-136; L365: Should use \\citep here  \nL170: observations  \nL348: Team?  \nL361: Missing label?  \nL710: full?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 2}, "code_of_conduct": {"value": "Yes"}}, "id": "PXOkmXyxt1", "forum": "mrafO7aTYj", "replyto": "mrafO7aTYj", "signatures": ["ICLR.cc/2026/Conference/Submission17517/Reviewer_nPHN"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission17517/Reviewer_nPHN"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission17517/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761834139578, "cdate": 1761834139578, "tmdate": 1762927396407, "mdate": 1762927396407, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper introduces LoRAGen, a method for generating Low-Rank Adaptation (LoRA) parameters directly from natural language task descriptions. The authors argue that LoRA parameter spaces have unique structural properties that are ignored by general-purpose weight-space learning methods. They identify two key properties from an empirical analysis: (1) the **non-uniqueness of low-rank decomposition**, where task similarity correlates with the full adaptation matrix $\\Delta W = BA$ but not with the individual $A, B$ matrices, and (2) the **heterogeneity of weight distributions**, where different modules (e.g., encoder, decoder) exhibit different spectral properties. To address these, LoRAGen introduces two main innovations: 1. **Adapter-level supervision** and 2. **Module-aware MoE decoder**. The overall framework uses a LoRA Weight Autoencoder (LAE) and a conditional latent diffusion model to generate latents from task descriptions, which are then passed to the MoE decoder. Experiments on FLAN-T5 and Gemma-2 models show that LoRAGen achieves performance close to task-specific (oracle) LoRAs on in-distribution tasks and, more importantly, outperforms the T2L (Text-to-LoRA) baseline by nearly 5% on zero-shot generation for unseen tasks."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "1.  The paper is grounded in a clear and compelling empirical analysis (Figure 1). The two observations (non-uniqueness and heterogeneity) are well-demonstrated and provide a strong \"why\" for the proposed method.\n2.   The proposed solutions map directly to the identified problems. The adapter-level supervision (direction and spectral loss) is a very clever way to address the non-uniqueness issue. The authors also correctly note the importance of an *efficient* implementation (Appendix A.3), which avoids materializing the $d \\times d$ matrix and makes the approach practical.\n3.   The primary goal of such a model is to generalize to new tasks. The 5% absolute improvement on zero-shot generation (Table 3) over the T2L baseline is a significant and meaningful result, demonstrating the value of the structure-aware approach.\n4.  The method is shown to be effective on both encoder-decoder (FLAN-T5) and decoder-only (Gemma-2) architectures, suggesting the principles are general.\n5.  The paper is well-organized, and the progression from observation to method to results is logical and easy to follow."}, "weaknesses": {"value": "1. The main weakness is the ablation study in Table 4. The model with just the MoE decoder and a standard reconstruction loss (\"X\", \"X\", \"✓\") achieves 95.2% average accuracy. The full model, with the novel adapter-level losses (\"✓\", \"✓\", \"✓\"), achieves 96.0%. This 0.8% difference on in-distribution tasks seems to *undermine* the importance of the adapter-level supervision ($L_{ang}$ and $L_{spec}$), which is presented as a primary contribution.\n2.  Related to Weakness #1, the paper argues that the adapter-level losses are critical for *generalization* and avoiding \"memorizing\" specific decompositions, which is key for zero-shot performance. However, the ablation study in Table 4 is *only* performed on in-distribution tasks. The most critical ablation—showing the zero-shot performance of the \"MoE + reconstruction\" model (the 95.2% one)—is missing. Without this, the central claim that the novel losses are *necessary* for zero-shot generalization is not fully substantiated.\n3.  The \"Average LoRA\" baseline results in Table 2 are clearly an error. The values appear to be copy-pasted from Table 1, and they show scores (e.g., 96.8 on ArcC) that are vastly higher than the \"Task-specific LoRAs\" (the oracle, 76.7). This is a sloppy error that should have been caught."}, "questions": {"value": "1.   The ablation in Table 4 suggests your novel adapter-level losses ($L_{ang}$, $L_{spec}$) provide only a marginal (0.8%) benefit on in-distribution tasks over a standard reconstruction loss when the MoE decoder is used. You motivate these losses as being essential for zero-shot generalization. To support this claim, please provide the **zero-shot ablation results** for the seven unseen tasks (the same setup as Table 3). Specifically, what is the zero-shot performance of the model with *only* the MoE decoder and a reconstruction loss (the one that scored 95.2% in Table 4)? This is crucial to validate your central contribution.\n2.  Please correct the \"Average LoRA\" baseline results in Table 2. The current values are nonsensical, as they significantly outperform the task-specific oracle.\n3.  Have you analyzed the expert specialization in your MoE decoder? The routing is based on module and layer embeddings, motivated by Obs-2 (heterogeneity). Do the experts indeed learn to specialize on specific module types (e.g., encoder vs. decoder) or spectral-entropy profiles as hypothesized?\n4.  What is the training time and parameter-count overhead of LoRAGen (for Stage 1) compared to the T2L baseline? How much do the adapter-level losses and MoE decoder add to the computational cost?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "RfEl5SPF4Z", "forum": "mrafO7aTYj", "replyto": "mrafO7aTYj", "signatures": ["ICLR.cc/2026/Conference/Submission17517/Reviewer_miEg"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission17517/Reviewer_miEg"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission17517/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761964993133, "cdate": 1761964993133, "tmdate": 1762927395987, "mdate": 1762927395987, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}