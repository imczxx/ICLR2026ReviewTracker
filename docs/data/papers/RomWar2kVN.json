{"id": "RomWar2kVN", "number": 16317, "cdate": 1758263085945, "mdate": 1763587824841, "content": {"title": "How Many Code and Test Cases Are Enough? Evaluating Test Cases Generation from a Binary-Matrix Perspective", "abstract": "Code evaluation and reinforcement learning rely critically on test cases. However, collecting golden test cases is hard and expensive, motivating the use of LLMs for automatic test case generation.\nThis, in turn, raises a pivotal challenge: how can we rigorously evaluate the quality of the generated test cases?\nExisting benchmarks often evaluate the exclusion ratio on large, unstructured collections of wrong codes, leading to high computational costs and severe score inflation. \nFurthermore, they inadvertently reward generators that detect common, trivial bugs, while failing to penalize their inability to identify rare yet critical faults.\nIn this work, we connect two fundamental questions: (1) What is the minimal set of wrong codes sufficient to represent the entire error space? and (2) What is the minimal set of test cases needed to distinguish them?\nWe introduce a novel framework that formalizes benchmark construction as finding an optimal diagnostic basis in a binary code-test matrix, where rows represent wrong codes and columns represent test case results.\nThe rank of this matrix plays a dual role. It specifies the minimal number of independent error patterns, which determines the size of wrong codes. It also provides a tight upper bound on the number of test cases required for complete fault coverage.\nOur objective is to identify a basis of size equal to the matrix rank that maximizes internal diversity, which is defined as the average pairwise Jaccard similarity of the codes' failure signatures (i.e., the matrix rows). \nTo tackle this NP-hard problem, we propose WrongSelect, an efficient approximation algorithm combining pre-filtering and random-restart local search to select maximally diverse wrong codes. \nApplying this framework to millions of competitive programming submissions, we construct TC-Bench, a compact, diverse, and inflation-resistant benchmark. Extensive experiments show that even the most advanced test case generation methods achieve only ~60\\% exclusion rates on TC-Bench, exposing a significant gap in their diagnostic power and highlighting substantial room for future improvement.", "tldr": "", "keywords": ["Code LLMs;Benchmark;Evaluation;Test Case"], "primary_area": "datasets and benchmarks", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/47a080acaf2f8c6c07bdc338972492dca74b332e.pdf", "supplementary_material": ""}, "replies": [{"content": {"summary": {"value": "This work addresses the challenge of evaluating automatically generated test cases for code using LLMs. The authors propose a new framework that models the relationship between code and test cases as a binary matrix, where the matrix rank reveals the minimal number of distinct wrong codes and test cases needed for evaluation. They introduce WrongSelect, an efficient algorithm for selecting a maximally diverse and representative set of wrong codes to form a compact benchmark, TC-Bench. Built from millions of competitive programming submissions, TC-Bench offers an efficient, diverse, and inflation-resistant benchmark for assessing test-case generation. Evaluation across 13 leading LLMs show that even the best current methods achieve only around 60% fault detection, highlighting significant room for improvement in automated test generation and evaluation."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "- Formulating problem as code-test matrix\n- Number of evaluated LLMs\n- Approximation algorithm\n- Benchmark construction"}, "weaknesses": {"value": "- Source of data from programming contests\n- Theoritically ok, but what about practicality?\n- Not studying other similarity metrics"}, "questions": {"value": "- How practical is this technique in practice/industry?\n- Do you think your technique generalizes on other datasets, when your evaluation is only using programming contests?\n- Do you think other similarity metrics would fit better than Jaccard?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "X8aszRMCUa", "forum": "RomWar2kVN", "replyto": "RomWar2kVN", "signatures": ["ICLR.cc/2026/Conference/Submission16317/Reviewer_D88H"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission16317/Reviewer_D88H"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission16317/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761518891036, "cdate": 1761518891036, "tmdate": 1762926455680, "mdate": 1762926455680, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper addresses how to rigorously evaluate LLM-generated test cases by reframing benchmark construction as a binary matrix problem over wrong codes (rows) and golden tests (columns). The central idea is to select a compact yet representative set of wrong codes that preserves the matrix’s diagnostic capacity while avoiding redundancy and score inflation. Concretely, the authors require the kept rows to form a row basis whose size equals the matrix rank (capturing all independent error modes), and among all such bases, they choose one that maximizes diversity by minimizing average pairwise Jaccard similarity of failure signatures.\n\nThey propose WrongSelect, an efficient approximation combining principled pre-filtering and random-restart local search. Pre-filtering drops problems with any all-ones test column (hack-prone) and removes trivial wrong codes that fail ≥80% of tests; then the local search swaps rows in/out while maintaining rank to minimize the diversity objective."}, "soundness": {"value": 4}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "1. The paper presents a fresh and elegant formulation that connects test selection to linear algebra. \n\nModeling wrong-code failure signatures as rows in a binary matrix and selecting a rank-preserving, diversity-maximizing row basis is a principled way to eliminate redundancy while retaining all independent error modes. This perspective clarifies what “good coverage” means and gives a theoretical upper bound on minimal tests.\n\n2. The empirical results are strong. \n\nThe proposed selection method yields a compact, diverse benchmark that meaningfully stresses current test generators, and the reported exclusion rates show clear, consistent improvements over baselines. The ablations and end-to-end evaluations convincingly demonstrate both effectiveness and practicality at scale."}, "weaknesses": {"value": "1. The approach assumes access to a sufficiently rich pool of golden tests (public + private) to build informative failure profiles. \n\nIn many real-world settings, curating or synthesizing high-quality golden tests is costly and time-consuming. This reliance reduces the method’s portability and makes it difficult for third parties to reproduce or extend the benchmark to new domains or problem sets without significant investment.\n\n2. While the formulation is theoretically sound (rank preservation plus diversity), the paper provides limited qualitative analysis to illustrate practical effectiveness. \n\nConcrete case studies—e.g., representative wrong-code examples retained vs. removed, error modes uncovered by the selected basis, or developer-facing insights derived from the reduced matrix—would strengthen the claim that the method improves understanding and diagnosis beyond raw metrics."}, "questions": {"value": "could you provide an example for the effectiveness of your approach in a code example?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 8}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "IdMqiqLLtq", "forum": "RomWar2kVN", "replyto": "RomWar2kVN", "signatures": ["ICLR.cc/2026/Conference/Submission16317/Reviewer_tPeL"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission16317/Reviewer_tPeL"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission16317/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761756723078, "cdate": 1761756723078, "tmdate": 1762926455146, "mdate": 1762926455146, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper proposes a new benchmark to evaluate LLMs' ability to generate high quality test cases for coding problems. The quality is determined by the efficiency in covering the error space of the problem. To improve quality representation of the error space, the authors form an error matrix, consisting of all the submissions by their pass/fail results on all the test cases. Since the rank of this 2D matrix conveniently represents the \"coverage\" of submission patterns, they develop a greedy algorithm to maximize the diversity of wrong code submission, which in return reduces to a more compact submission set for efficient evaluation.\nThe authors then evaluate several test case generation methods on various LLMs on two major metrics – the accuracy of generated test cases (PR) and the degree of successful filtering of wrong code submissions (HR). The evaluation results show that the choice of generation method matters significantly more than the choice of the underlying LLM. At the same time, the relatively underwhelming numbers (best combo leads to 60~% in HR) points to the importance of constructing a high quality set of wrong code – the analysis on the unfiltered version of the dataset reveals inflated scores, which is inaccurate."}, "soundness": {"value": 3}, "presentation": {"value": 2}, "contribution": {"value": 4}, "strengths": {"value": "* A meaningful contribution for a much-needed area, both in terms of efficiency and framework. The method can see practical use cases. \n* The proposed method for selecting the minimal set of wrong code submissions is principled and reasonable.\n* The outcome dataset effectively pinpoints the need for better TCG methods, citing the underwhelming numbers."}, "weaknesses": {"value": "* Apple-to-apple comparison against the previous work: It would be stronger if you could replicate the other test case evaluation methods on the same problem set and show how TC-Bench more critically measures the TCG quality by LLMs. I'm aware this is done partially by comparing the method against the \"All WC\" counterpart.\n* WrongSelect's robustness: It's uncertain if the greedy algorithm yields a stable set of problems. \n* The need of translation: I assume the dataset is entirely sourced from non-English problems. The choice of data sources affect the quality and the number of (valid) wrong code submissions for problems. Have authors explored English data? Reducing the submission count to less than 2% depends on the population of wrong code submissions.\n\n---\n\nBelow are NOT the weaknesses of the method, but I think they are important to raise for a higher quality submission. I'm leaving here as I don't see fit in \"Questions\"\n* Presentation 1: Overall there is high usage of acronyms, such as \"some WCs labeled as WA under GTs produce RE or TLE when executed on ATs\". I got used to it by the end a little bit, but I often had to go back and refresh my glossary many times. I'd highly suggest fixing the inconsistency (e.g., \"wrong code\" and WC) and reducing overall abbreviations.\n* Presentation 2: Plot styles are inconsistent – mostly comic sans but some of them serif (Times?) out of a sudden. It looks like being patched together. I recommend following a single style.\n* Appendix B has no content"}, "questions": {"value": "* How much variance in PR / HR do you observe by running the optimization multiple times? When you say convergence, do they arrive at the same set of WCs?\n* The analysis comparing the method against the \"All WCs\", are the all WCs before or after pre-filtering?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "PEf6dsWQWA", "forum": "RomWar2kVN", "replyto": "RomWar2kVN", "signatures": ["ICLR.cc/2026/Conference/Submission16317/Reviewer_jxDY"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission16317/Reviewer_jxDY"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission16317/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761851996610, "cdate": 1761851996610, "tmdate": 1762926454096, "mdate": 1762926454096, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper addresses an important problem in LLM evaluation: how to construct an efficient, reliable, and unbiased benchmark for assessing the quality of automatic test case generation methods. The core contribution is a novel framework based on binary-matrix theory. This framework uses the matrix rank to simultaneously determine the minimal number of wrong codes required for evaluation and a theoretical upper bound on the number of test cases needed for full error pattern coverage. Based on this framework, the authors devised WrongSelect to find an approximate solution to this NP-hard problem, culminating in the construction of TC-Bench."}, "soundness": {"value": 2}, "presentation": {"value": 3}, "contribution": {"value": 2}, "strengths": {"value": "1. The paper tackles the crucial challenge of evaluating test case generation methods for code.\n2. The author processes an efficient approximation algorithm combining pre-filtering and random-restart local search, WrongSelect. This provides a reasonable and effective solution to the NP-hard problem of selecting a maximally diverse diagnostic basis from a vast collection of wrong codes.\n3. The authors release a compact and diverse benchmark, TC-Bench. By design, TC-Bench can reduce the computational cost of evaluation and is resistant to score inflation."}, "weaknesses": {"value": "1. Insufficient discussion of related work. The paper could be strengthened by a more thorough discussion of related work that also leverages code-test properties. For instance, CodeT [1] or other approaches that also use binary matrices, such as B4 [2].\n\n2. Limited theoretical justification for the rank-coverage duality. A central claim of the paper is that the matrix rank provides an upper bound on the minimum number of test cases required for fault coverage. While the paper lacks a formal proof or a detailed discussion to substantiate this claim. A deeper analysis would strengthen the claim beyond intuition.\n\n3. Limitations of the chosen diversity metric. The paper employs Jaccard similarity to measure the overlap. It implicitly assumes that all GTs are of equal importance. In practice, some GTs may represent extremely rare and critical edge cases, while others are more trivial. The Jaccard metric cannot capture this weighted difference. Have the authors experimented with or considered other similarity metrics that could account for the varying significance of different test cases?\n\n[1] Chen, Bei, et al. \"CodeT: Code Generation with Generated Tests.\" The Eleventh International Conference on Learning Representations.\n\n[2] Chen, Mouxiang, et al. \"B4: Towards optimal assessment of plausible code solutions with plausible tests.\" Proceedings of the 39th IEEE/ACM International Conference on Automated Software Engineering. 2024."}, "questions": {"value": "See Weaknesses. I will be glad to raise my score if the authors could provide a sufficient rebuttal."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "R0uJrrLU56", "forum": "RomWar2kVN", "replyto": "RomWar2kVN", "signatures": ["ICLR.cc/2026/Conference/Submission16317/Reviewer_tm2i"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission16317/Reviewer_tm2i"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission16317/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761987244770, "cdate": 1761987244770, "tmdate": 1762926453651, "mdate": 1762926453651, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}