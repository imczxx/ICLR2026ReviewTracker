{"id": "E7ZZRnBQU7", "number": 19430, "cdate": 1758296204706, "mdate": 1763707526476, "content": {"title": "Sharing State Between Prompts and Programs", "abstract": "The rise of large language models (LLMs) has introduced a new type of programs: Natural language programs. By writing prompts directing LLMs to perform natural language processing, code generation, reasoning, etc., LLM users are writing code in natural language for the LLM to execute. \nAn emerging trend of active research enables interoperability between natural language and formal languages such as Python.\nWe present a novel programming abstraction: Shared program state.\nShared program state removes the work of enabling interoperability between natural code---natural language prompts---and the program state from the programmer.\nWith shared program state, programmers can write natural code that directly write program variables, compute with objects, and implement control flow in the program.\nWe present a template for designing natural function interfaces to extend system support for natural code.\nWe specified shared program state as a natural function interface and implemented it as the Nightjar programming system. \nNightjar enables programmers to write executable Python programs containing natural code using the shared program state abstraction.\nOur evaluation shows that  programs with shared program state achieves the same program accuracy as manually written implementations by programmers (66-75%), while decreasing the lines of code by 23.8% to 82.1%.", "tldr": "We present a novel programming abstraction, shared program state, that enables programmers to use natural language prompts to to directly write program variables, compute with objects, and implement control flow in programs.", "keywords": ["natural language programming", "large language model", "programming languages"], "primary_area": "neurosymbolic & hybrid AI systems (physics-informed, logic & formal reasoning, etc.)", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/c7c00ccf90b92fb81de60b3c7946e5956fcda96b.pdf", "supplementary_material": "/attachment/57cb7a5736c5a67e3bc6cefc703fa48803075c0d.zip"}, "replies": [{"content": {"summary": {"value": "The paper introduces **Shared Program State (SPS)**, a novel abstraction allowing natural-language code (prompts) and traditional programming languages (like Python) to **share variables, objects and control flow**. It defines a schema called the Natural Function Interface (NFI) that models this sharing via operations like `Lookup`, `Assign`, `Goto` etc. The authors implement this in a system called NIGHTJAR, which co-executes Python and natural code. Empirical evaluation (on a 25-program benchmark) shows comparable accuracy with much shorter code (23-82% fewer lines), albeit with higher runtime overhead.\n\n**Key Contributions**\n1. Definition of the Shared Program State abstraction and its semantics for mixing natural and formal code.\n2. Formalization of the Natural Function Interface (NFI) schema for the interaction.\n3. Implementation (NIGHTJAR) demonstrating how natural language code can manipulate program state in a host language.\n4. Empirical study (SPSBench) showing productivity gains (code conciseness) and feasibility of SPS, with noted runtime cost."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 2}, "strengths": {"value": "* The paper introduces a novel abstraction; the idea that prompts (natural-language code) and traditional programming languages can share program state; variables, heap objects, control flow. This moves beyond prior work that treated prompts as black-box tool calls or code generation endpoints. For example, [A] considers prompts as programs but does not formalize shared variable/state semantics between NL and formal code). [B] supports collaborative prompt engineering, but again focuses on prompt sharing/management rather than state-sharing semantics between NL and host code.\n* The combination of techniques is also creative: using an LLM as a \"natural interpreter\", defining an interface (Natural Function Interface) that models state-manipulation effects (assign, lookup, goto) and handlers in a host language. Prior works on NL to code generation (e.g., prompt-based learning, chain-of-thought) separate the code generation from program execution; here the \"code\" (NL) directly manipulates execution state. For instance, the \"Program of Thoughts\" [C] work uses LMs to generate a program which is then executed externally (i.e., separate stages). In contrast, this paper merges the NL/code boundary via shared state. That creative combination marks a strong originality.\n* The clarity of the interface model (Natural Function Interface), and the way the paper formalises values/effects/handlers, suggests technical rigor. This goes beyond more HCI-oriented prompt papers (e.g., CoPrompt [B]) which focus on usability rather than formal semantics.\n\n```\n[A] Prompts Are Programs Too! Understanding How Developers Build Software Containing Prompts, FSE 2025\n[B] CoPrompt: Supporting Prompt Sharing and Referring in Collaborative Natural Language Programming, CHI 2024\n[C] Program of Thoughts Prompting: Disentangling Computation from Reasoning for Numerical Reasoning Tasks, TMLR 2023\n```"}, "weaknesses": {"value": "* The empirical evaluation uses a 25-program suite (e.g., SPSBench) that demonstrates the abstraction in a limited number of tasks. It is unclear how well the approach scales to larger, more complex programs, especially ones with deeply nested state, concurrency, or rich object graphs.\n* The implementation incurs a substantial runtime penalty (11.7–15.3× slower) due to the involvement of an LLM interpreting natural code. While the paper acknowledges it, the evaluation does not fully explore how this overhead affects usability in real-world settings. Many practitioners may find this cost prohibitive.\n* Allowing natural-language code to manipulate host program state (variables, heap, control flow) introduces risks: unintended side-effects, state inconsistency, security holes, debugging difficulty. The paper acknowledges safety issues but does not deeply evaluate them (e.g., what happens if the NL code assigns to a variable incorrectly, or dereferences invalid references).\n* While the “shared program state” abstraction is compelling, some of its components (NL interfacing with program state, prompts-as-programs) overlap substantially with prior work. For instance, [A] already frames prompts as programs. The novelty claim would be stronger if the paper explicitly differentiates itself from these works and shows how state-sharing goes beyond \"prompts as programs\" and prior tool-calling frameworks.\n* Although the formalism is strong, there may be a steep learning curve for typical developers: understanding effects/handlers, bridging NL syntax with host language semantics, maintaining coherence in hybrid code. The paper could provide more empirical evidence on developer usability: how quickly developers adapt to writing natural code that manipulates host state, what errors or misunderstandings occur. In contrast, works like CoPrompt [B] focus on developer workflows and collaboration in prompt engineering and report usability metrics.\n```\n[A] Prompts Are Programs Too! Understanding How Developers Build Software Containing Prompts, FSE 2025\n[B] CoPrompt: Supporting Prompt Sharing and Referring in Collaborative Natural Language Programming, CHI 2024\n```"}, "questions": {"value": "* Is it possible to include a larger scale benchmark with more complex stateful programs (e.g., classes, inheritance, mutable collections, parallel threads) and evaluate how the shared state abstraction performs there (both correctness and latency)?\n* Is it possible to compare the performance (accuracy, conciseness, runtime) on tasks used in ANPL [A] or similar to increase external validity?\n* Is it possible to provide a deeper latency cost-benefit analysis (e.g., user-perceived delay, scalability with number of state operations, caching strategies for repeated NL manipulations)?\n* Is it possible to include a dedicated \"robustness\" evaluation: fault injection (NL commands that try invalid operations), tracking state invariants, measuring how many errors occur, how they are detected and recovered? Also are there guidelines or restrictions on NL code allowed (e.g., sandboxing, type checks, access control)?\n* Is it possible to add a discussion on how debugging mixed NL+code state will be supported (logging, visualization, stepping)?\n* Is it possible to deepen the literature comparison section: explicitly list prior abstractions (e.g., prompt-programming, tool-calling interfaces, NL-to-code) and highlight exactly how the shared -state model differs (e.g., direct variable reference, control flow manipulation)?\n* Is it possible to include a user study (even small-scale) with software engineers or prompt-programmers: measure how well they'd adopt the shared-state model, what errors are common, what cognitive load is involved?\n\n```\n[A] ANPL: Towards Natural Programming with Interactive Decomposition, NeurIPS 2023\n```"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "2L3wnLsdTJ", "forum": "E7ZZRnBQU7", "replyto": "E7ZZRnBQU7", "signatures": ["ICLR.cc/2026/Conference/Submission19430/Reviewer_KmWC"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission19430/Reviewer_KmWC"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission19430/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761916125319, "cdate": 1761916125319, "tmdate": 1762931355696, "mdate": 1762931355696, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The authors propose to enable LLM \"execution\" agents to directly interact with a host language program state to facilitate easier interaction between \"natural code\" and formal language code (programming languages). They define a Natural Function Interface (NFI) along with its operational semantics, and show how NFIs generalise tool use/MCP to a richer interaction semantics (shared state, shared control flow).\nThe authors then curate a benchmark dataset with natural code to evaluate their approach in terms of lines of code (after normalisation), pass-rate, and execution time. They show a significant reduction of code size (by making much of the serialisation, reisation implicit to the paradigm) while matching the manually written implementations in a majority of cases."}, "soundness": {"value": 3}, "presentation": {"value": 4}, "contribution": {"value": 3}, "strengths": {"value": "- Generalisation of tool use to shared program state (memory, control)\n- competitive results even with what seems like a naive implementation"}, "weaknesses": {"value": "- It is unclear how/where serialisation/data marshalling is to be implemented; it is also unclear if grammar-based sampling is compatible with the approach or if any such grammar file should be augmented to enable emission of effect tokens.\n- perhaps out of scope, but the handler loop seems unintuitive: if emitted effects are side-effect free wrt the program state that is observed by the NL code, why not stage an execution plan and delay the interrupts until the last moment possible to reduce overhead?\n- perhaps missing reference to literate programming (of ye olden days): Knuth, Donald Ervin. \"Literate programming.\" The computer journal 27.2 (1984): 97-111. Not directly the same concept, but it follows the spirit of literate programming\n- There is an unexplored trade-off frontier: in the paper, the comparison is the paradigm handling the boilerplate vs the user-written boilerplate. A fully FL/PL program vs a hybrid program would be another comparison of interest, but the cost normalisation is more difficult."}, "questions": {"value": "- Q1: The idea of shared state requires the model to be aware of how data can be manipulated (`graph.add_edge((14,5))`, etc.) and moving data via the handler requires serialisation and conversion back to the expected data-type (similar to FFI dtypes vs the host language dtypes). Who has the burden of defining these serialisation operations, Function symbol discovery, etc.?\n\n- Q2: While the implicit to the paradigm operations vs explicit boilerplate is explored in the paper, how does this compare to generating a single PL script that solves the task instead of switching PL/NL context?\n\n- Q3: How does NL execution handle stochasticity? Is the temperature set to 0?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "qq0v9VWuzx", "forum": "E7ZZRnBQU7", "replyto": "E7ZZRnBQU7", "signatures": ["ICLR.cc/2026/Conference/Submission19430/Reviewer_83Tw"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission19430/Reviewer_83Tw"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission19430/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761978956828, "cdate": 1761978956828, "tmdate": 1762931354807, "mdate": 1762931354807, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper introduces shared programs states between formal and natural programming languages. This is formalized with the concept of Natural Function Interfaces (NFIs), through values, effects and handlers for sharing scopes, heaps, and control states. The proposed system, NIGHTJAR, implements this shared program and enables natural language code to directly read, write, and manipulate the program state of a host language such as Python. The work is supported by theoretical grounding and a new benchmark suite (SPSBench) evaluating program conciseness and performance."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "- **Novel conceptual contribution**: The idea of exposing host-language state and control to an LLM in a principled and programmable way is novel. This moves beyond existing systems that treat LLMs as isolated components that make tool calls using programmer defined functions.\n- **Strong formal framework**: The authors present a formal framework for NFIs, including variable scopes, heap references, and control state.\n- **System implementation**: The NIGHTJAR system demonstrates that the abstraction is realizable and yields substantial code reduction  compared to manually writing interoperable code."}, "weaknesses": {"value": "- **Limited empirical evaluation**: The evaluation on program pass rates and conciseness, while adequate as proof of concept, does not deeply explore scalability, robustness, or user experience. \n- **Benchmarks are synthetic**: SPSBench appears to consist mainly of small programs adapted from documentation examples. It would be great to have analyses on real-world user code or larger-scale applications.\n- **Safety and correctness**: Though acknowledged in discussion, the implications of allowing natural code direct memory access (even through abstraction) deserve stronger treatment."}, "questions": {"value": "- **Execution times may be conservative**: Rather than relying only on LLM APIs, consider adding evaluations with smaller, locally hosted LLMs. \n- **Discuss failure modes**: Consider adding some analysis of where failures occur when they do."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 8}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "t8d0gdDWxI", "forum": "E7ZZRnBQU7", "replyto": "E7ZZRnBQU7", "signatures": ["ICLR.cc/2026/Conference/Submission19430/Reviewer_M1qm"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission19430/Reviewer_M1qm"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission19430/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762050292078, "cdate": 1762050292078, "tmdate": 1762931353832, "mdate": 1762931353832, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"title": {"value": "Summary of Changes"}, "comment": {"value": "We thank the reviewers for the thoughtful feedback and questions. We have added additional discussions and results requested by reviewers to the revised draft highlighted in blue. We list below a summary of the changes:\n\n- Related Work Section: Added paragraph headings and elaborated on differences between prior work and our work. Added related work mentioned by reviewers (Literate Programming, CoPrompt, ANPL, Prompting is Programming Too, Program of Thoughts Prompting)\n- Shared Program State NFI Section: Added clarification to NFI on when serialization/reification happens\n- Evaluation Section: Updated main experiment results and added Optimized Nightjar results \n- Discussion & Conclusion: Added paragraph on future work on program development tool\n- Appendix:\n    - Added LLM Compiler results to Appendix H\n    - Added Optimized Nightjar and caching results to Appendix I\n    - Added results with GPT-OSS 20B to Appendix J\n    - Added plot of the number of effects to runtime in Appendix K\n    - Added GSM8K results to Appendix L\n    - Added failure analysis to Appendix M"}}, "id": "iSQXifqJ37", "forum": "E7ZZRnBQU7", "replyto": "E7ZZRnBQU7", "signatures": ["ICLR.cc/2026/Conference/Submission19430/Authors"], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission19430/Authors"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission19430/-/Official_Comment"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1763707866386, "cdate": 1763707866386, "tmdate": 1763707866386, "mdate": 1763707866386, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Comment", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper introduces the idea of shared program state, essentially an LLM black box that can read and manipulate the program's internal state which can be steered somewhat by specialised syntax. The paper walks this idea through with an example, defines the proposed construct in eBNF and further explains the functionality of each component. The paper concludes with a reference implementation, nightjar, of the proposed idea and a lightweight empirical study with 25 programming examples which suggests that programmers using nightjar are about as proficient as programmers without it, while sacrificing execution time for conciseness."}, "soundness": {"value": 2}, "presentation": {"value": 3}, "contribution": {"value": 1}, "strengths": {"value": "I think the general idea of natural language programming interfaces is intriguing and has a rich history that goes well beyond the current LLM hype - indeed beyond deep learning."}, "weaknesses": {"value": "I am not convinced ICLR is the best avenue to publish this work. The empirical study is at best preliminary and I am not convinced at all that programmers would like to give up control and lose out on execution time for saving a few extra lines of code - with LLM-assisted code writing and analysis tools these come essentially for free.\n\nI suggest to greatly expand the scope of the empirical analysis, include evaluations on known public benchmarks as well as to incorporate qualitative feedback, analysis of failure modes, etc, to increase the scope of the contribution commesurate with ICLR."}, "questions": {"value": "No questions at this point."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "Js4UXSvpg0", "forum": "E7ZZRnBQU7", "replyto": "E7ZZRnBQU7", "signatures": ["ICLR.cc/2026/Conference/Submission19430/Reviewer_8swZ"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission19430/Reviewer_8swZ"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission19430/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762240392134, "cdate": 1762240392134, "tmdate": 1762931353342, "mdate": 1762931353342, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}