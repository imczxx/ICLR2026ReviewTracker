{"id": "rSxYPLzyBu", "number": 2680, "cdate": 1757195543515, "mdate": 1763699924511, "content": {"title": "GaugeKV: Composable Exact KV Cache Compression", "abstract": "The key–value (KV) cache is a dominant memory cost in long-context Transformer inference. We introduce GaugeKV, a training-free method that leverages the head-wise gauge symmetry of attention to reduce KV memory both exactly and with certificates. A one-time gauge canonicalization rewrites weights so that values are orthonormal and queries/keys are scale-balanced; thereafter the model produces K/V in a compression-friendly basis without changing its function or runtime FLOPs. Combined with lossless hot/cold staging, this yields bit-identical outputs (FP32 deterministic) with measurable KV reductions (e.g., 1.11×–1.21× on GPT-2; 1.13× key-side on Qwen2.5-7B).\nCrucially, the canonical basis makes these gains multiply with grouped/multi-query attention (GQA/MQA), yielding 4.6× total KV reduction for typical GQA (h=32, g=8) and 36.8× structural (73.6× total KV reduction with FP8, γ=0.5) for aggressive MQA (g=1, h=32). When further combined with FP8 quantization, total KV reductions can exceed 20×. Beyond exact savings, the canonical value basis turns rank-r value caching into a first-class primitive with a priori guarantees: we prove end-to-end bounds and observe 100% compliance at r=32 on GPT-2. Both tracks compose multiplicatively with grouped/multi-query attention, quantized KV, paging, and MoE—substantially extending feasible context on fixed VRAM.", "tldr": "GaugeKV reparameterizes Transformer heads into a canonical basis to losslessly compress the KV cache. It composes with GQA/MQA and FP8, preserves FP32-deterministic outputs, supports RoPE/MoE, and enables 4.6×–73.6× total KV-memory reduction", "keywords": ["KV cache", "Transformers", "Gauge Symmetry", "Gauge canonicalization", "GQA/MQA/MoE/RoPE"], "primary_area": "foundation or frontier models, including LLMs", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/5fad35e2a5e09a7651d22cacee5a677d50549ff5.pdf", "supplementary_material": ""}, "replies": [{"content": {"summary": {"value": "The paper introduces GaugeKV, a training-free method for KV cache compression based on the maximal gauge symmetry of attention. By performing a one-time canonicalization that orthonormalizes values and balances query/key scales, it enables bit-identical FP32 inference while improving lossless compression efficiency and supporting certified rank-r caching with provable error bounds. The method also composes multiplicatively with GQA/MQA and quantization. Overall, it provides a mathematically elegant framework for exact and composable KV cache compression."}, "soundness": {"value": 3}, "presentation": {"value": 2}, "contribution": {"value": 3}, "strengths": {"value": "1. The paper introduces a novel and mathematically grounded view of KV cache compression through the lens of gauge symmetry, revealing a complete class of function-preserving transformations for attention layers. This is a genuinely original theoretical contribution.\n\n2. The proposed method can be seamlessly integrated with other KV cache compression techniques to enhance the overall compression ratio further, making it (somehow) practically valuable for real-world deployment scenarios."}, "weaknesses": {"value": "1. Though mathematically elegant, the claimed efficiency improvement is questionable. The achievable compression ratio is rather limited and comes with substantial end-to-end latency overhead, as shown in Table 2. Since most modern models already employ RoPE, where the observed latency overhead is particularly high, it is unclear whether this transformation offers practical benefits in real deployment settings. Although the authors claim that this overhead can overlap with attention computation, I doubt this claim is too weak and lacks theoretical or empirical analysis on whether this is true. For example, is this process memory-bound or compute-bound, and how does it overlap with the attention?\n\n2. Though the authors claim that this method produces identical output, there is a lack of evaluation results on common benchmarks used in KV cache compression, and also some sample outputs to support this claim, as well as the claim for rank-r caching. The current experimental section is too limited and does not provide sufficient evidence to convincingly demonstrate the accuracy and effectiveness of the proposed method.\n\n3. The presentation is mathematically dense and at times difficult to follow, which may hinder accessibility for non-theoretical readers. Some sections, such as lines 74–82, are particularly heavy and could benefit from clearer exposition. I suggest that the authors include additional figures and empirical results to better illustrate the core ideas and clarify the practical impact of the method."}, "questions": {"value": "1. While the paper presents a theoretically elegant framework for exact KV compression, its practical efficiency and empirical validity remain unclear. Specifically, does this method truly provide end-to-end latency speedup in real-world settings? Can the compression process effectively overlap with computation? \n\n2. Additionally, more evidence on common benchmarks is needed to substantiate the claims of bit-identical outputs and certified rank-r caching beyond small-scale tests. How does the model using this method perform in commonly used benchmarks compared to baselines such as full precision, from both the accuracy and latency aspects?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "Ed2NRDIHv3", "forum": "rSxYPLzyBu", "replyto": "rSxYPLzyBu", "signatures": ["ICLR.cc/2026/Conference/Submission2680/Reviewer_oBrJ"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission2680/Reviewer_oBrJ"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission2680/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761505995593, "cdate": 1761505995593, "tmdate": 1762916329644, "mdate": 1762916329644, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "GaugeKV rewrites the weights once, offline, by multiplying them with fixed invertible matrices. This change in basis allows KV compression to become more lossless, and the paper demonstrates this through effective lossless codecs and safe rank truncation. Specifically, Values $V$ are orthonormalized; after a thin-QR on $W_V$, the model emits values in an orthonormal coordinate system. In this basis, token-to-token residuals are smaller and more concentrated near zero, which directly improves both bit-packing and entropy coding efficiency. In addition, balancing Q/K scales reduces plane-wise skew, so shared bit-width choices across dimensions waste fewer bits on outliers. After canonicalization, the FP32 forward remains bit-identical and a lossless codec yields 1.1×–1.2× KV reduction on GPT-2 and 1.1× on the keys for Qwen2.5-7B. Since the method only changes the model weights and not inference-time algorithm, decoding FLOPs remain the same (or smaller if you use their certified rank-r value caching).\nThe paper's contributions are as follows:\n- A constructive canonicalization: Thin‑QR on $W_V$ makes $V$ orthonormal and a geometric‑mean balancing map that equalizes $Q/K$ scales (restricted to the RoPE commutant for RoPE models).\n- An exact, lossless KV pipeline using the canonical basis. Due to its exactness, the method can be composable with other pre/post-training KV compression methods, such as GQA and KV quantization.\n- A certified rank‑r value caching scheme that shows the observed logit drift stays within the bound at every step."}, "soundness": {"value": 2}, "presentation": {"value": 1}, "contribution": {"value": 2}, "strengths": {"value": "- Originality: The gauge-symmetry framing is relatively original, though there were many previous efforts, whether lossless or nearly lossless, that consider change of basis and rotation.\n- Significance: The paper provides a method that any Transformer-based model can use for KV compression without any degradation. Due to its exactness, the method works orthogonally and may work in tandem with other methods, though this should be empirically verified.\n- Quality: see weakness.\n- Clarity: see weakness."}, "weaknesses": {"value": "1. **Minor KV reductions (not state-of-the-art)**: The gains of GaugeKV are at most 1.2x, measured with a reference entropy codec in a single-pass, teacher-forced microbench. The gains are very modest compared to the typical KV quantization/eviction gains, which are at least 3x or more (e.g., see KIVI, GEAR, Cartridge). The reduction is minor that practitioners would prefer more significant reductions at the price of nearly lossless compression.\n  - **Misleading compression rates**: I find it incredibly misleading to report compounded reduction rates that include GQA and FP8 quantization. In particular, GQA/MQA are not post-training compression methods (at least not without pruning), so most KV compression papers treat these as default and report how much gain is achieved from the model checkpoint. These are not contributions of the paper, but over-emphasized in the main body.\n2. **Unverified claims on composability w.r.t. rank-r value caching**: The paper’s multiplicative composition (Eq. 2) is demonstrated for the exact, lossless GaugeKV; it does not establish accuracy preservation when rank-r (lossy) is stacked with KV quantization (lossy) or eviction (lossy), so the claims in Section 7 (related work) can be misleading. Rank-r’s certified envelope (Eq. 5) upper-bounds only the error from the value-rank projection in FP32; additional quantization or token-retention errors are outside that certificate and could compound. Yet, once combined with other methods, this certificate no longer holds true. It would be great to see if rank-r value caching is practically composable.\n  - **Lack of downstream tasks**: The rank-r section is strong theoretically and shows 100% compliance of the logit-drift envelope on GPT-2 @ r=32, but there are no task metrics (e.g., perplexity or accuracy on QA) to translate drift into end-task safety/utility.\n3. **Unorganized presentation and superfluous math notation**: The paper reads like a series of bullet points and the list of lemma, corollary, proposition makes it hard to follow. The main message can be more direct and clear, but the gauge-theoretic framing, which is more of proof technique than message, is interesting but obscures that the method is a standard reparameterization by invertible maps. Furthermore, the paper is hard to follow as many variables are left undefined and left for the reader to infer from the context."}, "questions": {"value": "1. **Proposition 2.8 Appendix E**: \nThe construction in Thm. 2.8 (Appendix E) with $(S_Q=W_Q^\\top W_Q), (S_K=W_K^\\top W_K), (M=S_Q^{1/2} S_K S_Q^{1/2})$, the paper sets $A = S_Q^{-1/4} M^{1/4} S_Q^{-1/4}$\nand claims this yields $A^\\top S_Q A = A^{-1} S_K A^{-\\top} = S_Q \\sharp S_K.$ (p.3–4 & App. E.1).\nUnless I am missing something, $(A^\\top S_Q A = S_Q^{-1/4} M^{1/4} S_Q^{1/2} M^{1/4} S_Q^{-1/4})$ does not simplify to $M^{1/2}$ (or $S_Q \\sharp S_K$) unless the factors commute. However, choosing $A = S_Q^{-1/2} M^{1/4}$\ndoes satisfy $A^\\top S_Q A = M^{1/2} = S_Q \\sharp S_K$\nand $A^{-1} S_K A^{-\\top} = M^{1/2} = S_Q \\sharp S_K$,\nbecause $A^{-1} = M^{-1/4} S_Q^{1/2}$ and\n$M^{-1/4} (S_Q^{1/2} S_K S_Q^{1/2}) M^{-1/4} = M^{1/2}$. This avoids any commutativity assumption. So can the authors provide a brief proof or explanation that the paper’s form indeed yields S_Q # S_K?\n\n2. **Related to Figure 2**: it would be helpful to show (i) how the envelope tracks on a RoPE model, and (ii) downstream task metrics (perplexity, accuracy) under the certified envelope and not just logit drift, e.g., GSM8K accuracy or perplexity on some reference text.\n\nMisc.\n- L267: should the $L$ be a summation from $l=1$ to $L$? Otherwise, I don't understand the $l$ in $r_{l, i}$.\n- L570: \"Theorem\" -> \"Definition\"\n- Section K Reproducibility: the section is a unverifiable reproducibility statement when there is no (anonymous) codebase."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "qPHpI1XwBa", "forum": "rSxYPLzyBu", "replyto": "rSxYPLzyBu", "signatures": ["ICLR.cc/2026/Conference/Submission2680/Reviewer_ZbfF"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission2680/Reviewer_ZbfF"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission2680/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761952155697, "cdate": 1761952155697, "tmdate": 1762916329436, "mdate": 1762916329436, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper proposes GaugeKV, a training-free method for KV cache compression that exploits the maximal gauge symmetry of attention to reparameterize Transformer weights without changing model behavior. A one-time canonicalization makes values orthonormal and queries/keys scale-balanced, enabling both exact lossless compression and certified rank-r value caching. The method is theoretically sound and composes cleanly with existing optimizations such as GQA/MQA and quantization. While the reported compression gains are modest, the evaluation is somewhat unclear—there are data lack proper explanation, no accuracy results are provided for the approximate mode, and many experiments are limited to older GPT-2 models."}, "soundness": {"value": 3}, "presentation": {"value": 2}, "contribution": {"value": 3}, "strengths": {"value": "* The paper provides a rigorous characterization of the maximal gauge symmetry in Transformer attention, including a formal proof that the proposed transformations preserve function and are complete (no additional lawful symmetries exist). It's a far less explored area for KV-Cache compression.\n\n* The method integrates naturally with widely deployed optimizations such as GQA/MQA, quantization, and paging, offering multiplicative memory savings without architectural changes."}, "weaknesses": {"value": "* The proposed method has more restrictions for RoPE-based models than RoPE less models, while RoPE-based models are still the mainstream of today's LLMs.\n\n* The explanation on the experiment results is not sufficient. For example, Table 2 is not explained in the main paper content.\n\n* rank-r method which is not lossless. However, no downstream accuracy or perplexity are reported for rank-r.\n\n* The proposed method relied on good engineering implementation to avoid latency overhead. It's unclear if it's practical on a large-scale system."}, "questions": {"value": "* Can the method apply to newer attention variant such as Multi-Latent Attention (MLA) from deepseek?\n\n* For table 2, what is the baseline latency without any KV-Cache compression?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "lRPdHt09z0", "forum": "rSxYPLzyBu", "replyto": "rSxYPLzyBu", "signatures": ["ICLR.cc/2026/Conference/Submission2680/Reviewer_M5YW"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission2680/Reviewer_M5YW"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission2680/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761994420588, "cdate": 1761994420588, "tmdate": 1762916329287, "mdate": 1762916329287, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}