{"id": "ka82fvJ5f1", "number": 8068, "cdate": 1758057839984, "mdate": 1759897810468, "content": {"title": "Universal Model Routing for Efficient LLM Inference", "abstract": "Model routing is a simple technique for reducing the inference cost of large language models (LLMs), wherein one maintains a pool of candidate LLMs, and learns to route each prompt to the smallest feasible LLM. Existing works focus on learning a router for a fixed pool of LLMs. In this paper, we consider the problem of dynamic routing, where new, previously unobserved LLMs are available at test time. We propose UniRoute, a new approach to this problem that relies on representing each LLM as afeature vector, derived based on predictions on a set of representative prompts. Based on this, we detail two effective instantiations of UniRoute, relying on cluster-based routing and a learned cluster map respectively. We show that these are estimates of a theoretically optimal routing rule, and quantify their errors via an excess risk bound. Experiments on a range of public benchmarks show the effectiveness of UniRoute in routing amongst more than 30 unseen LLMs.", "tldr": "We propose a principled model routing framework which allows new models to be added to or removed from the serving pool without having to retrain the routing model.", "keywords": ["model routing", "adaptive computation", "learning to defer", "efficient inference"], "primary_area": "other topics in machine learning (i.e., none of the above)", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/72032fe4e8cca4a78540146ffe21ea121f0bf64c.pdf", "supplementary_material": ""}, "replies": [{"content": {"summary": {"value": "Model routing is an important problem in LLM serving. The focus has been on static model routing, but there is a need for dynamic model routing. The paper formulates the dynamic model routing problem and characterizes the optimal solution. From this, the authors derive a practical algorithms using prompt and model embeddings."}, "soundness": {"value": 2}, "presentation": {"value": 2}, "contribution": {"value": 4}, "strengths": {"value": "- Good formulation of the dynamic routing problem.\n- Good results on standard benchmarks."}, "weaknesses": {"value": "- Lack of rigor in Sec 5 (See my questions).\n- Unclear motivation for introducing clustering from first principles."}, "questions": {"value": "- Prop 1: If I understand correctly, the Lagrangian multiplier $\\lambda_{\\mathcal{h}}$ is specific to an instance of $x$ and $\\mathcal{H}$, while $\\mathcal{h}$ is the distribution of $\\mathcal{H}$. Therefore, denoting this multiplier as $\\lambda_{\\mathcal{h}}$ is confusing. Please correct me if I am wrong.\n- Implication of Prop 1: the optimal $r^\\star$ for Eq 5 is the minimizer to Eq 6 for some $\\lambda_{\\mathcal{h}}$. However, it does not mean that optimizing over $\\lambda_{\\mathcal{h}}$ and Eq 6 is going to give us the optimal $r^\\star$ for Eq 5. Therefore, the suggestion of tuning $\\lambda_{\\mathcal{h}}$, while being something sensible to do, is simply ignoring Prop 1. I want to hear the reasoning on why this is still a good idea. Maybe we are implicitly optimizing another optimization problem when doing so. The main problem is that it is not clear whether the values of $\\lambda_{\\mathcal{h}}$ satisfying Prop 1 can be found constructively.\n- Unclear formulation in Sec 4: for simplicity, let $\\Phi \\in R^{|X| \\times K}$, $\\Psi \\in R^{|H| \\times K}$. Hence, $\\Phi \\Psi \\in R^{|X| \\times |H|}$ (I'm assuming the transpose in (9) is a typo). Suppose that $|X|=1$, then $\\gamma$ is a vector function? From (8), I got the impression that the domain of $\\gamma$ is $R_+$. Therefore, something about the current formulation does not add up.\n- Line 271: underperform vs what?\n- Unclear motivation for clustering in Sec 5: What is the reason to clustering here? Is it only for computational efficiency?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "qf5ZvykYjp", "forum": "ka82fvJ5f1", "replyto": "ka82fvJ5f1", "signatures": ["ICLR.cc/2026/Conference/Submission8068/Reviewer_44vL"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission8068/Reviewer_44vL"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission8068/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761089873886, "cdate": 1761089873886, "tmdate": 1762920058311, "mdate": 1762920058311, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The paper studies LLM routing under dynamic model pools, where test-time available LLMs may differ from training-time ones. It proposes UniRoute, which learns a bilinear scoring function γ(x, h) = Φ(x)ᵀΨ(h). Prompts are embedded (and clustered) once; LLMs are represented by their per-cluster error rates on a small validation set. Routing is then simple cost-adjusted argmin over any test-time pool. The paper gives a Bayes-optimal rule for the dynamic setting and an excess-risk bound for the cluster-based instantiation. Experiments on four public routing-style benchmarks with 30+ unseen LLMs show UniRoute outperforms strong dynamic baselines (ZeroRouter, K-NN) and avoids retraining costs."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "- Relevant problem: tackles a practical, current task where LLM/agent methods are still brittle, the problem choice is well motivated.\n- The components fit together: the modeling choices are consistent with the objective, and the pipeline is implementable without exotic assumptions.\n- Across multiple datasets/settings, the method shows consistent improvements over the stated baselines, not just one cherry-picked case.\n- There is at least some attempt at digging into why it works (error breakdown / qualitative examples), which is better than many incremental papers.\n- Reproducible direction: The paper uses mostly standard toolchains; another group should be able to re-implement this without reverse-engineering half the setup."}, "weaknesses": {"value": "- Ablations are thin: key modules are turned on/off only in one setting; we don’t see if the effect is stable across datasets/scales. A 2–3 row ablation table per main component would already help.\n- Limited robustness reporting: no real stress test (distribution shift, noisier inputs, or lower-resource regime). Right now, the method looks tuned to a friendly setup.\n- Clarity on compute/cost: method adds some overhead but the paper doesn’t quantify it clearly; for adoption, people will want to know the inference/training cost relative to the simplest baseline."}, "questions": {"value": "1. Can you add results or at least a justified comparison against the most recent approach(es) that use a similar intermediate representation? Right now the reader has to guess how your method would fare against them.\n2. Ablation depth: If you ablate the proposed module but keep the training data / hyperparams the same, how much of the gain remains? This would confirm it’s not just better tuning.\n3. Compute: What is the actual training cost (GPU-hours, model size) and inference latency delta vs. the strongest baseline?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "XJJXd7rIpF", "forum": "ka82fvJ5f1", "replyto": "ka82fvJ5f1", "signatures": ["ICLR.cc/2026/Conference/Submission8068/Reviewer_fvKV"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission8068/Reviewer_fvKV"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission8068/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761959053494, "cdate": 1761959053494, "tmdate": 1762920057819, "mdate": 1762920057819, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper studies the problem of dynamic model routing for LLM inference: given a prompt and a pool of candidate LLMS of different cost, select the cheapest model that will still answer well, even when the candidate pool dynamically changes. Existing work mostly assumes a static pool, and retrains the router whenever a new model appears, which is impractical and expensive. The authors formalize routing with a dynamic pool and propose UniRoute, which represents each LLM as a feature vector using its prediction error on the validation dataset, and represents each input prompt via a learned embedding. Then, they estimate for each model and prompt pair the probability of error plus a cost term and pick the minimum. Two examples of UniRoute are presented; they are clustering-based routers where prompts are grouped into clusters learned using the training dataset. The authors argue that these are approximations to an optimal routing rule and provide an excess risk bound. Experimentally, the authors evaluate UniRoute against multiple baselines that cover static and dynamic routing methods on several public routing benchmarks. Empirically, UniRoute attains better cost accuracy tradeoff than baseline methods."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "- The paper addresses a realistic and under-explored setting. Most prior work focuses on a fixed pool of LLMs and require retraining when a new model is added, UniRoute explicitly designed to handle a dynamic pool of LLMs.\n- To my knowledge, the solution proposed by the authors is novel and quite simplistic. I think that the cluster-based example setups are practical and easy to implement. It is also cost-effective to adapt to new models.\n- The paper gives an explicit optimal routing rule that shows the tradeoff between the predicted error and the model cost via a Lagrangian multiplier. It also shows how UniRoute approximates that."}, "weaknesses": {"value": "- The given clustering-based examples rely on the representativeness of the validation dataset. While this works, the paper gives limited insight into sensitivity. What happens if clusters are not well aligned with the task structure? \n- The proposed method assumes that you have access to a validation dataset with labels. How could this be generalized to noisy labels for a validation dataset or a validation dataset without labels? (I think that an intuitive answer would be enough instead of running a whole set of experiments.)"}, "questions": {"value": "- UniRoute represents the performance of the new LLM via the bilinear form $\\Phi(x)^|\\top\\Psi(x)$. Can you explain why the bilinear form is expressive enough to model the interaction between prompts and models? Can there be more complex models that uses $\\Phi(x)$ and $\\Psi(x)$ as input features and estimates the performance?\n\nTypos\n- Line 330, \"... incorrect predic let...\"\n- Line 386, missing \".\" at the end of the sentence."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 8}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "kDvcZ83MUm", "forum": "ka82fvJ5f1", "replyto": "ka82fvJ5f1", "signatures": ["ICLR.cc/2026/Conference/Submission8068/Reviewer_n7Fp"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission8068/Reviewer_n7Fp"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission8068/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761965918835, "cdate": 1761965918835, "tmdate": 1762920057450, "mdate": 1762920057450, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The paper studies routing among multiple LLMs when the model pool can change after training. The idea is to fingerprint each model by taking its error to a validation set, giving us a way to then route promots to a cluster and let us estimate which model will do best. They cover two approaches, one which is K-means clusters and one which is a learned assignment. This produces budget-and-quality frontier improvements over baselines on a range of benchmarks and models."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "1. The set of evaluations is very broad and shows consistent gains against reasonable baselines\n2. The test-time approach is amenable to many real use cases\n3. The method is cognisant of cost, as opposed to naively just optimising for performance"}, "weaknesses": {"value": "1. The set of metrics is relatively narrow; it would be good to cover generation metrics as some other methods do\n2. It is unclear how robust this is to shifts in distribution compared to the validation set"}, "questions": {"value": "How stable is the cost-tuning knob across datasets and model pools?\nHow does this look on non-binary metrics?\nAre there subgroups or adversarial examples which can reduce performance?\nIs it possible to combine this with a learned router for seen models to get improvements when comparing to a static pool?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 8}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "GkujNWj1UZ", "forum": "ka82fvJ5f1", "replyto": "ka82fvJ5f1", "signatures": ["ICLR.cc/2026/Conference/Submission8068/Reviewer_vMrd"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission8068/Reviewer_vMrd"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission8068/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761988086277, "cdate": 1761988086277, "tmdate": 1762920057013, "mdate": 1762920057013, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}