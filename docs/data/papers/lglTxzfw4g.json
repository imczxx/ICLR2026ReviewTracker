{"id": "lglTxzfw4g", "number": 12516, "cdate": 1758208348618, "mdate": 1759897504564, "content": {"title": "Forge: Foundational Optimization Representations from Graph Embeddings", "abstract": "Combinatorial optimization problems are ubiquitous in science and engineering. Still, learning-based approaches to accelerate combinatorial optimization often require solving a large number of difficult instances to collect training data, incurring significant computational cost. Existing learning-based methods require training dedicated models for each problem distribution, for each downstream task, severely limiting their scalability and generalization. We introduce Forge: Foundational Optimization Representations from Graph Embeddings, a framework that pre-trains a vector-quantized graph autoencoder on a large, diverse collection of mixed-integer programming (MIP) instances in an unsupervised manner, without relying on optimization solvers or optimal solutions. Vector quantization produces discrete code assignments that serve as a vocabulary for representing optimization instances. We evaluate Forge in both unsupervised and supervised settings. In the unsupervised setting, Forge embeddings effectively cluster unseen instances across problem domains and sizes. In the supervised setting, we fine-tune Forge embeddings and show that a single pre-trained model helps predicting both the integrality gap for cut-generation and variable hints for search guidance across multiple problem and size distributions. In both tasks, we improve the performance of a commercial optimization solver and outperform state-of-the-art learning-based methods. Finally, we open-source our training code, pre-trained Forge weights, and embeddings for multiple MIP distributions to foster further research in representation learning for optimization problems.", "tldr": "Foundational model generates local (vars/constraints) and global (instance-level) embeddings for optimization, self-supervised training without any/optimal solutions. A single pre-trained model outperforms commercial and SOTA ML across tasks/problems", "keywords": ["combinatorial optimization", "graph machine learning", "foundational embeddings", "unsupervised learning"], "primary_area": "learning on graphs and other geometries & topologies", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/1f001b3c9f9275a54e83021aa8943ca68fbc34cc.pdf", "supplementary_material": "/attachment/8655fe8040f764389334816f9ebf919690e16085.zip"}, "replies": [{"content": {"summary": {"value": "This paper proposes Forge, a framework for learning unsupervised representations of Mixed-Integer Programming (MIP) instances. The core idea is to pre-train a Vector-Quantized Graph Autoencoder (VQ-GAE) on a diverse corpus of MIP instances, creating a discrete \"vocabulary\" of codes. These codes are used to generate instance-level and variable/constraint-level embeddings. The authors evaluate Forge in two settings: (1) unsupervised clustering of MIP instances, where it shows strong performance, and (2) supervised fine-tuning on two downstream tasks: integrality gap prediction for pseudo-cut generation and variable prediction for search guidance. The paper claims that a single pre-trained Forge model serves as a \"foundational\" model, generalizing across problems, sizes, and tasks, and demonstrates its utility by integrating predictions into the Gurobi solver."}, "soundness": {"value": 2}, "presentation": {"value": 1}, "contribution": {"value": 1}, "strengths": {"value": "1. The overarching goal of creating a general-purpose, unsupervised representation for MIP instances is highly relevant and ambitious.\n\n2. The results in Section 4 are compelling. Forge embeddings clearly and effectively cluster unseen MIP instances from different problem families and difficulties, significantly outperforming the provided baselines. This is a strong, demonstrable capability."}, "weaknesses": {"value": "1. The term \"Foundational\" in the title and throughout the paper is a significant overstatement. With a model size of 3.25M parameters trained on only 2,850 instances, Forge is orders of magnitude smaller in scale and scope than true foundational models (e.g., BERT, GPT). Its generality is confined to the MIP domain, and it functions more as a well-pre-trained, general-purpose graph encoder for MIPs. This framing risks creating misplaced expectations.\n\n2. The experimental design for the supervised downstream tasks is the paper's most critical weakness. The primary baseline for solver performance is often the default Gurobi solver. For a claim of foundational generality, comprehensive comparisons against other *learning-based* methods are essential and largely missing. For integrality gap prediction, the comparison to Li et al., 2025 is conducted on different test sets (Forge on 400 problem types vs. Li et al. on 157), making the claimed superiority difficult to interpret fairly. For search guidance, the claimed SOTA is not PS-Gurobi. A more relevant and stronger baseline for a neural MIP solver is Apollo-MILP. The absence of a comparison to such a method leaves the reader uncertain about Forge's true standing.\n\n3. The VQ component is central to the method. However, the ablation study in Appendix A.4 shows that clustering performance (NMI) is largely insensitive to the codebook size. This raises a fundamental question: Is the added complexity of VQ justified? A simpler global pooling mechanism might achieve similar results, and the paper does not provide conclusive evidence to the contrary.\n\n4. The description of the initial node features is confusing. The text states: \"For each node, we obtain a vector of size 10\". However, it separately lists 4 features for constraint nodes and 6 for variable nodes. It is critical to clarify whether all nodes are represented with a 10-dimensional vector where 4/6 dimensions are zero-padded based on node type, or if the feature sets are kept separate in the model.\n\n5. The improvement from augmenting PS-Gurobi with Forge embeddings (Figure 6) is compelling but potentially misleading. The ablation in Appendix A.8 shows that adding *random vectors* also improves performance, likely due to the increased input dimensionality and thus model capacity."}, "questions": {"value": "1. Given the model's relatively small scale (3.25M parameters, 2.8k training instances), do you agree that the term \"Foundational\" might be an overstatement? How would you define the minimum criteria for a \"foundational model\" in combinatorial optimization?\n\n2. Can you provide more direct evidence that VQ is crucial for the *supervised downstream task* performance?\n\n3. For task 1, the supervised fine-tuning datasets are quite small. Have you experimented with increasing the amount of supervised data?\n\n4. Regarding the 10-dimensional node feature vector: could you please explicitly detail its construction? Is it a unified 10-D vector for all nodes (with zero-padding), or are variable and constraint node features processed separately by the GNN?\n\n5. The need to design custom loss functions and prediction heads for each task suggests that the representation is not directly transferable without significant adaptation. What is your vision for how a practitioner would use Forge for a *new*, third task (e.g., cut selection or branching)? Does this process still require similar task-specific engineering, and if so, how does this align with the concept of a foundational model?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 5}, "code_of_conduct": {"value": "Yes"}}, "id": "yOBPXETXgd", "forum": "lglTxzfw4g", "replyto": "lglTxzfw4g", "signatures": ["ICLR.cc/2026/Conference/Submission12516/Reviewer_VZ9M"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission12516/Reviewer_VZ9M"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission12516/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761542362932, "cdate": 1761542362932, "tmdate": 1762923385241, "mdate": 1762923385241, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This work proposes a method for learning embeddings for MIP problem instances using graph embeddings. Each MIP is encoded as a bipartite graph, with variables and constraints making up the two partitions, respectively. A GNN embedding is then trained, which is converted to a quantized representation with a codebook, and then decoded to minimize a reconstruction loss. In an unsupervised setting, this approach is demonstrated to effectively cluster unseen problem instances. In a supervised setting, pre-trained FORGE models are fine-tuned for specific problem types and shown to outperform Gurobi without FORGE, as well as SOTA ML methods."}, "soundness": {"value": 3}, "presentation": {"value": 4}, "contribution": {"value": 3}, "strengths": {"value": "The paper is well written and easy to follow. The motivation and problem space are clearly articulated, and constitute an important area of research. The results are strong."}, "weaknesses": {"value": "I would appreciate details of the loss function in the paper itself. At the very least, the notation that is used in the main text should be introduced outside of the appendix.\n\nTypo line 338 “results” -> “result”\n\nThe discussion of limitations reads mainly like a list of strengths and future work. Do the authors anticipate any drawbacks to this method? Are there problems that are typically cast as MIP instances that are likely to be difficult using FORGE?"}, "questions": {"value": "How expensive is fine-tuning compared with training comparator ML methods? This tradeoff seems important for those who are considering FORGE compared to a method designed for specific CO problems."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 8}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "vCFwN91Vxh", "forum": "lglTxzfw4g", "replyto": "lglTxzfw4g", "signatures": ["ICLR.cc/2026/Conference/Submission12516/Reviewer_gCtA"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission12516/Reviewer_gCtA"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission12516/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761571949170, "cdate": 1761571949170, "tmdate": 1762923384939, "mdate": 1762923384939, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper presents an unsupervised framework, **FORGE**, designed to learn foundational representations for Mixed-Integer Linear Programming (MILP) problems through bipartite graph embeddings and vector quantization. The work is novel and technically sound, addressing a long-standing gap — how to construct general-purpose optimization representations without relying on solvers or labeled data. It makes a meaningful contribution to the intersection of combinatorial optimization and representation learning."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 2}, "strengths": {"value": "1. The paper is pioneering in its attempt to build a “foundational model” for optimization, similar to those in natural language processing (NLP) and computer vision (CV). By combining bipartite graph structures with a vector-quantized autoencoder, it achieves general structural encoding for optimization instances.\n\n2. The model’s training does not depend on optimal solutions or solver outputs, enabling large-scale unsupervised pretraining across diverse problem distributions.\n\n3. The authors present systematic experiments on both unsupervised clustering and supervised downstream tasks (integrality gap prediction and search guidance). They use multiple datasets, including MIPLIB, D-MIPLIB, and strIPlib, and show performance improvements when integrated with the GUROBI solver.\n\n4. A single pre-trained model demonstrates effective transfer across different problem types, sizes, and tasks, suggesting strong generalization potential."}, "weaknesses": {"value": "1. **Limited Interpretability**: The discrete “optimization vocabulary” generated through vector quantization lacks semantic clarity, making it difficult to interpret the structural meaning of each code. This limitation affects the model’s scientific transparency and trustworthiness. Providing insights into relational structures between tokens, similar to language model embeddings, would strengthen the paper’s claims.\n\n2. **Restricted Solver Integration**: The embeddings are currently applied only once during the initialization phase (for pseudo-cut generation or variable hinting) without dynamic interaction with the branch-and-bound process. This raises questions about the model’s actual impact during the solving process.\n\n3. **Narrow Task Coverage**: The experiments focus on two downstream tasks and do not evaluate classic optimization tasks such as variable selection or node selection. This limitation weakens the generality claim of the model."}, "questions": {"value": "1. Have you conducted an analysis of the semantics of the vector-quantized codes? For example, do these codes correspond to specific constraint motifs or variable structures? Providing visualizations or examples of inter-token relationships would be beneficial.\n\n2. Is representing global features as a **frequency vector** appropriate? Since this approach ignores the graph’s edge structure, could it fail to distinguish between graphs that are structurally different but statistically similar?\n\n3. In the pseudo-cut experiments (primal gap–time plots), would it not be more appropriate to compare against other pseudo-cut generation methods? Comparing only “with vs. without pseudo-cuts” may be insufficient, as adding cuts naturally tightens the search space and accelerates convergence.\n\n4. Have you performed additional experiments to demonstrate the representational capacity of the tokens? For instance, using GNNs for variable selection could validate the effectiveness of the tokens.\n\n5. Is there an ablation study showing whether downstream performance improvements are truly driven by the learned token representations? For example, do the results degrade if tokens are randomly chosen or slightly offset in the codebook?\n\n6. Could you provide a table summarizing the optimization improvements achieved by the two experiments across different datasets and problem scales? This would help in better understanding the practical impact of your work."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "krYP1auzbo", "forum": "lglTxzfw4g", "replyto": "lglTxzfw4g", "signatures": ["ICLR.cc/2026/Conference/Submission12516/Reviewer_pUdN"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission12516/Reviewer_pUdN"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission12516/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761618395212, "cdate": 1761618395212, "tmdate": 1762923384368, "mdate": 1762923384368, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The paper introduces FORGE (Foundational Optimization Representations from Graph Embeddings), a framework designed to create general-purpose MIP embeddings that can serve multiple combinatorial optimization tasks without relying on solver-specific solutions. FORGE is a vector-quantized graph autoencoder trained on a diverse set of Mixed-Integer Programming (MIP) instances in an unsupervised manner. The key contributions include the creation of a foundational model capable of producing embeddings for optimization instances that can generalize across problem domains and sizes. The paper demonstrates the use of these embeddings in both unsupervised and supervised settings, improving solver performance and outpacing existing learning-based methods in tasks like integrality gap prediction and search guidance. The approach is designed to work with commercial solvers like GUROBI, showing significant improvements in optimization tasks such as cut-generation and variable prediction for search guidance."}, "soundness": {"value": 3}, "presentation": {"value": 3}, "contribution": {"value": 3}, "strengths": {"value": "1.\nFORGE leverages unsupervised learning to pre-train embeddings from a wide range of MIP instances, creating general-purpose representations that can be used across multiple optimization tasks and problem sizes without needing optimal solutions or labeled data. This broadens its applicability compared to other supervised or task-specific models.\n\n2.\nThe FORGE embeddings show strong generalization capabilities across different problem domains and sizes. The method not only works for one specific task but can be fine-tuned to improve performance for various tasks, such as integrality gap prediction and search guidance, demonstrating versatility and adaptability.\n\n3.\nFORGE is integrated with GUROBI, a commercial optimization solver, and improves primal gaps for several problem types. The pre-trained embeddings help enhance solver performance, reducing gaps and speeding up convergence."}, "weaknesses": {"value": "1.\nAlthough FORGE performs well, the interpretability of the learned embeddings remains unexplored. The paper briefly mentions that some codes may represent local structures like cliques, but a deeper understanding of how different parts of the embedding space correspond to specific problem features would be valuable.\n\n2.\nWhile the model is compact (with 3.25 million parameters), training on very large datasets might still pose challenges in terms of computational resources. The ability to scale this model to even larger MIP instances (e.g., 100K+ nodes) while maintaining efficiency needs further investigation.\n\n3.\nThe experiments are focused on MIP-based optimization tasks, but there is limited exploration of how FORGE can generalize to other combinatorial optimization problems, like SAT or constraint satisfaction problems (CSPs). Exploring other problem domains would enhance the general applicability of the model.\n\n4.\nWhile the paper shows that FORGE improves GUROBI, it doesn't discuss how easily it can integrate with other solvers or whether solver-specific adjustments might be necessary. More clarity on this would help understand its broader applicability in real-world use cases."}, "questions": {"value": "1.\nHow well do FORGE embeddings generalize to non-MIP combinatorial optimization problems such as SAT or CSP? Could the embeddings be applied effectively in domains beyond MIPs, and what adaptations, if any, would be needed?\n\n2.\nWhile the model shows promising results for problems with up to a few thousand variables, how does it scale to extremely large MIP instances (e.g., 100K variables)? Would further optimizations or adjustments to the architecture help maintain efficiency and accuracy?\n\n3.\nCan the authors provide more insights into the semantic meaning of the learned discrete codes? How can the embeddings be analyzed or visualized to better understand the underlying optimization structures they capture?\n\n4.\nHow does the fine-tuning process work across various domains? Is there any risk of overfitting to a specific problem domain if fine-tuning is not handled carefully, or does the pre-training help mitigate this issue effectively?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 5}, "code_of_conduct": {"value": "Yes"}}, "id": "ZAtysL72k9", "forum": "lglTxzfw4g", "replyto": "lglTxzfw4g", "signatures": ["ICLR.cc/2026/Conference/Submission12516/Reviewer_DQAb"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission12516/Reviewer_DQAb"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission12516/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761840533677, "cdate": 1761840533677, "tmdate": 1762923384001, "mdate": 1762923384001, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}