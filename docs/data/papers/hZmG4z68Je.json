{"id": "hZmG4z68Je", "number": 18847, "cdate": 1758291420153, "mdate": 1759897077955, "content": {"title": "Training-Free Self-Scheduling for Efficient LLM Inference Serving", "abstract": "The ability to deliver fast responses under strict latency requirements is critical for Large Language Model (LLM) inference serving. \nMost existing systems rely on a first-come-first-served (FCFS) scheduling policy, which often suffers from head-of-line blocking. \nWhile a number of solutions have been proposed, they typically require training additional models or auxiliary predictors, such as BERT, to estimate decoding lengths. \nThese approaches limit generalization and necessitate retraining for new domains or distributions.\nTo address these limitations, we propose self-scheduling with LLM, a novel approach that leverages the reasoning capabilities of the LLM itself without requiring extra training or auxiliary models. \nWe systematically investigate a range of feasible strategies and conduct extensive analyses. Experimental results show that our method achieves up to a 5$\\times$ improvement in TTFT, a 3$\\times$ improvement in TPOT, a 6$\\times$ reduction in latency, and a 9$\\times$ increase in throughput under both general and domain-specific workloads, with negligible overhead.\nThis work offers a lightweight yet intelligent scheduling paradigm, demonstrating both practicality and strong potential for LLM inference serving.", "tldr": "We introduce a self-scheduling approach for LLM inference that avoids head-of-line blocking and achieves very high improvements in latency and throughput without extra models or retraining.", "keywords": ["Large Language Model", "Inference Serving", "Scheduling Algorithms", "Efficient Inference"], "primary_area": "infrastructure, software libraries, hardware, systems, etc.", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/3e90d1902bb4bca3376b73bb9f1a038711b9073f.pdf", "supplementary_material": ""}, "replies": [{"content": {"summary": {"value": "This paper proposes training-free self-scheduling for LLM serving: instead of training a separate length predictor, the deployed LLM itself estimates response length (or ranks requests by expected length) to prioritize short jobs. Reported gains over FCFS include up to 5× lower TTFT and 3× lower TPOT on several workloads."}, "soundness": {"value": 2}, "presentation": {"value": 3}, "contribution": {"value": 2}, "strengths": {"value": "- The paper is clearly written and well structured; the core idea and its three variants (PrefillOnly, RankOnly, and LengthOnly) are easy to follow.\n- The approach is practical and drop-in, avoiding the maintenance of auxiliary predictors while remaining compatible with standard serving stacks."}, "weaknesses": {"value": "- The work does not include head-to-head comparisons against prior training-based schedulers ([1][2]) or “LLM-tells-its-length” methods ([3]), which makes it difficult to assess competitiveness beyond FCFS.\n\n- The methodology risks inflating TTFT because it decodes tokens to estimate length or ranking before scheduling, so the first token for many requests may be delayed unless all ranking/prefill tokens are rigorously counted and reported. Can you provide more evidence that on why the TTFT is improved? \n\n[1] Qiu, Haoran, et al. \"Efficient interactive llm serving with proxy model-based sequence length prediction.\" arXiv preprint arXiv:2404.08509 (2024).\n\n[2] Fu, Yichao, et al. \"Efficient llm scheduling by learning to rank.\" Advances in Neural Information Processing Systems 37 (2024): 59006-59029.\n\n[3] Zheng, Zangwei, et al. \"Response length perception and sequence scheduling: An llm-empowered llm inference pipeline.\" Advances in Neural Information Processing Systems 36 (2023): 65517-65530."}, "questions": {"value": "- Please add controlled baselines that include a trained length regressor/classifier and an LLM-length-prediction method, matched for model, backend, and compute budget.\n\n- Please break out and charge all scheduling overhead (prefill/ranking tokens) to TTFT/TPOT, and report sensitivity under varying load to clarify the true latency impact."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "6cFfTQppyV", "forum": "hZmG4z68Je", "replyto": "hZmG4z68Je", "signatures": ["ICLR.cc/2026/Conference/Submission18847/Reviewer_sbTa"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission18847/Reviewer_sbTa"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission18847/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761681632518, "cdate": 1761681632518, "tmdate": 1762930815732, "mdate": 1762930815732, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper proposes training-free self-scheduling for LLM inference: instead of training an auxiliary length and rank predictor, the server uses the LLM itself to rank incoming requests by expected response length and schedules short ones first to mitigate head-of-line blocking. Three variants are explored.\n\nThe paper also introduces a rank-aware anti-starvation mechanism. Experiments across NuminaMath, TACO, ShareGPT report up consistent latency and throughput improvements, with small extra overhead."}, "soundness": {"value": 2}, "presentation": {"value": 2}, "contribution": {"value": 2}, "strengths": {"value": "1. Cleverly reuses the served LLM for ranking/length estimation, avoiding auxiliary latency/length predictors and reducing system complexity while still improving tail throughput.\n\n2. Empirically shows clear gains over prefill-only (logit probe) baselines, suggesting self-scheduling is a promising direction."}, "weaknesses": {"value": "1. The paper lacks experiment details and does not specify, up front, which models are used for serving and self-scheduling (this appears only later in Fig. 9). It leads to confusion during reading. \n\n2. Missing baseline comparisons. There’s no comparisons against other baseline methods for (i) ranking overhead and (ii) rank-match quality.\n​\n3. Insufficient system analytics across loads: Table 2 analyzes a single operating point (rate = 64, bsz = 1). The paper lacks load sweeps (QPS/RPS); would be good to vary load and report **throughput** as well."}, "questions": {"value": "1. Can you provide comparisons with baseline schedulers in terms of ranking overhead and system performance (TTFT/TPOT/throughput) under identical settings? Please include rank-match metrics.\n\n2. Insufficient throughput characterization. In addition to Table 1, could you add experiments with varying RPS, showing how goodput/throughput changes with and without self-scheduling? \n\n3. How does the system behave at low/medium/high RPS? Since re-ranking adds overhead, have you explored adaptive re-ranking frequency (e.g., disable or downsample re-ranking at high load) vs. always re-rank all requests? Quantitative results across load regimes would clarify the trade-offs."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "3O5X4mOPg7", "forum": "hZmG4z68Je", "replyto": "hZmG4z68Je", "signatures": ["ICLR.cc/2026/Conference/Submission18847/Reviewer_sXso"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission18847/Reviewer_sXso"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission18847/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762036102100, "cdate": 1762036102100, "tmdate": 1762930814859, "mdate": 1762930814859, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper proposes training-free self-scheduling for LLM inference: instead of training an external length predictor, the serving LLM itself briefly “judges” a small pack of pending requests to estimate relative response lengths and decide execution order, aiming to reduce head-of-line blocking under FCFS. The method is positioned as lightweight (no extra models, no retraining) and broadly applicable across domains.\nClaimed contributions are: (1) a training-free LLM self-scheduling paradigm; (2) three concrete strategies with tie-aware evaluation; (3) empirical validation of latency/throughput improvements; and (4) a rank-aware anti-starvation mechanism for fairness."}, "soundness": {"value": 2}, "presentation": {"value": 3}, "contribution": {"value": 2}, "strengths": {"value": "1.Proposes a training-free self-scheduling paradigm that leverages the serving LLM itself—rather than auxiliary predictors—to estimate relative response lengths and order requests, reframing scheduling as an in-model reasoning task. This is a creative repurposing of “LLM-as-a-Judge” ideas to systems scheduling and removes the retraining barrier present in prior work.\n\n2.Executes a multi-dataset study (NuminaMath, TACO, ShareGPT) on an 8×A100 vLLM stack with sensible P95/P99 metrics for TTFT/TPOT/latency; reports consistent advantages of LengthOnly and includes throughput tables under fixed-time and fixed-workload settings."}, "weaknesses": {"value": "1.Although the proposed system does not introduce an auxiliary predictor, the serving model itself must perform additional reasoning (ranking prompts) before actual decoding. This inevitably increases TTFT and overall latency, since the same LLM is doing both scheduling and generation. Under high-concurrency workloads, it is unlikely that such overhead remains negligible, as the ranking step can stall GPU pipelines and disrupt prefill scheduling.\n\n2.All experiments are conducted at moderate request rates. The authors should explicitly evaluate two contrasting real-world scenarios:\nLow-latency regime — set batch_size = 1 to test per-request responsiveness.\nHigh-concurrency regime — stress the scheduler under large-scale Poisson arrivals to test throughput stability."}, "questions": {"value": "1.Is the ranking step executed synchronously on the same GPU stream as decoding, or asynchronously in parallel?\n\n2.Can the authors provide per-stage timing (prefill, ranking, decoding) to quantify how much TTFT and latency increase per batch?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "YAjT7hSii3", "forum": "hZmG4z68Je", "replyto": "hZmG4z68Je", "signatures": ["ICLR.cc/2026/Conference/Submission18847/Reviewer_Uwso"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission18847/Reviewer_Uwso"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission18847/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762135718994, "cdate": 1762135718994, "tmdate": 1762930814371, "mdate": 1762930814371, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper proposes self-scheduling with LLM, a novel approach that leverages the reasoning capabilities of the LLM itself without requiring extra training or auxiliary models. Given a set of requests, it prompts the LLM to provide a relative ranking of their expected response lengths. The LLM outputs a predicted rank ˆR, where ties are allowed (i.e., multiple requests may be assigned the same rank). Experiments show the performance."}, "soundness": {"value": 2}, "presentation": {"value": 2}, "contribution": {"value": 2}, "strengths": {"value": "1. Request scheduling for LLM serving system is important.\n\n2. Training-free self-scheduling, especially PrefillOnly, is simple and efficient.\n\n3. Experiments show the performance."}, "weaknesses": {"value": "1. The main concern is the experiments may not fit practical serving system. In experiments, Req/s seems to be insufficient and does not fully utilize the GPU computation power. Based on Figure 6, TTFT and TPOT decreases with the increase of Req/s. If keep increasing Req/s, TTFT and TPOT should increase.\n\n2. The extra latency can be better evaluated. In section 5.4 EXTRA COST, what is 20 math requests with rate = 64? Could the authors show the result with huge amount of requests?\n\n3. Code is node provided."}, "questions": {"value": "Separate prefilling and decoding in different servers may improve the performance."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "CVuoHDYdAn", "forum": "hZmG4z68Je", "replyto": "hZmG4z68Je", "signatures": ["ICLR.cc/2026/Conference/Submission18847/Reviewer_8YDv"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission18847/Reviewer_8YDv"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission18847/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762233599893, "cdate": 1762233599893, "tmdate": 1762930813418, "mdate": 1762930813418, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The paper introduces a training-free self-scheduling method  that leverages the reasoning capatilities of LLMs to estimate model output lengths. Instead of relying on auxiliary models or tools to estimate response lengths, the authors propose three strategies to rank latency or predict request lengths for scheduling."}, "soundness": {"value": 3}, "presentation": {"value": 2}, "contribution": {"value": 3}, "strengths": {"value": "1. The method is simple and straightforward. \n2. The method does not require extra training or auxiliary tools.\n3. The method can be adapted widely across different modesl and datasets.\n4. The method is efficient and easy to integrate.\n5. The authors designed a starvation control method to prevent queries from waiting for long."}, "weaknesses": {"value": "1. The method requires additional decoding, which slightly introduce additional overhead.\n\n2. I’m concerned about the practical applicability of the proposed method. The starvation control method is somehow naive. In real-world scenarios, some queries with long response sizes may be more important yet still experience long waiting times. Determining scheduling priority based on estimated response length may be weak when handling diverse requirements in real AI services."}, "questions": {"value": "See weaknesses"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 6}, "confidence": {"value": 3}, "code_of_conduct": {"value": "Yes"}}, "id": "JoFHx1QrnH", "forum": "hZmG4z68Je", "replyto": "hZmG4z68Je", "signatures": ["ICLR.cc/2026/Conference/Submission18847/Reviewer_XZZm"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission18847/Reviewer_XZZm"], "number": 7, "invitations": ["ICLR.cc/2026/Conference/Submission18847/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762929513979, "cdate": 1762929513979, "tmdate": 1762930812903, "mdate": 1762930812903, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}