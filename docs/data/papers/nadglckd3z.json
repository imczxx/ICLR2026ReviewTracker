{"id": "nadglckd3z", "number": 13400, "cdate": 1758217409682, "mdate": 1759897440145, "content": {"title": "A Versioned Unified Graph Index for Dynamic Timestamp-Aware Nearest Neighbor Search", "abstract": "We present TiGER (Time-Integrated Graph for Efficient Retrieval), a novel approach for performing fast time-aware approximate nearest neighbor searches on dynamic vector datasets with flexibility over any possible time range. Our proposed algorithm constructs and maintains a unified graph for all vectors by utilising an index structure based on integrated, versioned connectivity, enabling direct querying of arbitrary time intervals on the unified graph without traversing invalid vectors. This forgoes the need for post-search filtering or merging, or to construct and/or save separate graphs for each possible composite range. Empirical evaluations show that our method attains up to a 5x improvement in queries per second (QPS) without compromising accuracy over state-of-the-art baselines based on filtering or per-time-segment sub-graphs. We believe that this method will enable efficient temporal analysis across evolving datasets in real-time recommendation systems, log analysis, and any scenario that requires fast similarity search over dynamic, time-segmented data.", "tldr": "We introduce TiGER, a unified graph-based method for fast and accurate time-filtered ANN search on dynamic datasets.", "keywords": ["approximate nearest neighbor search", "recommender systems", "time series"], "primary_area": "optimization", "venue": "ICLR 2026 Conference Submission", "pdf": "/pdf/97eb9537f171966e6774673552d3395805324f19.pdf", "supplementary_material": ""}, "replies": [{"content": {"summary": {"value": "This paper proposes a new method for ANN search over temporal graphs. The paper presents the proposed algorithm and some experiments without a clear problem statement, complexity analysis, or dataset description."}, "soundness": {"value": 2}, "presentation": {"value": 2}, "contribution": {"value": 2}, "strengths": {"value": "The research problem is practically interesting."}, "weaknesses": {"value": "1. The writing could be improved. I would like to see a more formal problem statement for such a type of work, since temporal queries do have a large number of variations.\n2. Incomplete literature review. There are a lot of studies on querying versioned graphs (maybe under different names such as dynamic graph, temporal graph, etc.). Many of them date back to the 2000s. Although they may not be suitable for embeddings, it is still necessary to mention them, explaining their deficiencies and emphasizing the novelties of this research.\n3. Algorithms 1 & 2 are over-lengthy with unnecessary programming-level details.\n4. The proposed method is for discrete timestamps. In this work, by “continuous”, the authors actually mean consecutive timestamps. However, in practice, time is really continuous. Discretizing time may lead to a huge number of timestamps, making the algorithm computationally prohibitive.\n5. There’s no theoretical (in particular, complexity) analysis, which I believe is unacceptable for such a type of work.\n6. No dataset description in Sec. 4 (content, size, etc.). I cannot understand the experiments."}, "questions": {"value": "See detailed comments."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "hMJ5CNgiM5", "forum": "nadglckd3z", "replyto": "nadglckd3z", "signatures": ["ICLR.cc/2026/Conference/Submission13400/Reviewer_GWcD"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission13400/Reviewer_GWcD"], "number": 1, "invitations": ["ICLR.cc/2026/Conference/Submission13400/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761961790164, "cdate": 1761961790164, "tmdate": 1762924035503, "mdate": 1762924035503, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The paper provides a procedure to solve the ANNS problem with timestamp constraints. This problem is indeed important. It provides some novel ideas on how to handle timestamp filters, timestamp range filters and also dynamic insertions.\n\nHowever, I feel, the comparison to previous baselines should be done in experiments section in a much thorough manner. The value of current contributions is not evident from the experiments performed. As this is an empirical paper, I feel changing some of the algorithms from the prior work for the problem studied is important to have meaningful baselines to do comparison against.\n\nI liked the ideas presented in the paper on handling timestamp filters and also range filters. However, after reading the paper, I don't yet know how good the algorithm is. More experiments should be done to convince me the value of the algorithm presented. The authors should also talk about space usage, build times and other important metrics. The shortcomings of the proposed approach should also to be discussed in the paper.\n\nOverall, the paper has promising ideas. Further revision will make it stronger and worthy to be accepted at venues like ICLR. I am leaning in the middle for this paper: that is, neither accept or reject."}, "soundness": {"value": 3}, "presentation": {"value": 2}, "contribution": {"value": 3}, "strengths": {"value": "1) To handle timestep filters, I liked that the authors introduced timesteps for edges and they maintain graph connectivity among vertices associated with a particular time step.\n\n2) The idea for handling range filters is also nice."}, "weaknesses": {"value": "1) I feel the writeup could be done better. For instance, in your write up, please separate problem statement from your procedure to solve it. You could clearly state what the problem statement is.\n\n2) The experiment section also looks very primitive. Not lot of effort in adding other baselines has been done. For non-range filter queries, you should compare your approach with existing methods and show that yours does well."}, "questions": {"value": "1) Would you please state the problem statement formally somewhere? I mean, mathematically, what is the problem that you are trying to solve. Also by dynamic, you mean only insertions? Are there no deletions?\n\nAre documents arriving in an online fasshion? How is a timestep associated with a document defined? Is it given as input to the index algorithm? In particular, please explain the problem statement exactly. Is t_{v} and active(v) part of inputs to the index building algorithm?\n\n\n2) Why is Filtered-DiskANN not part of your baselines? It can handle dynamic inserts I think. This is just one of the algorithms which can be directly applied in your setting. \n\n3) If there are baselines which cannot handle insertions but can handle filters, can we just compare your approach to these baselines where there are no new insertions?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 4}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "tUHgJYNOdU", "forum": "nadglckd3z", "replyto": "nadglckd3z", "signatures": ["ICLR.cc/2026/Conference/Submission13400/Reviewer_C2Gy"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission13400/Reviewer_C2Gy"], "number": 2, "invitations": ["ICLR.cc/2026/Conference/Submission13400/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1761991929686, "cdate": 1761991929686, "tmdate": 1762924035010, "mdate": 1762924035010, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "This paper proposes a time-constrained approximate nearest neighbor search method for data with assigned timestamps. The proposed approach extends graph-based neighbor search methods by associating each node with timestamp information and employing various auxiliary structures to enable timestamp-aware search."}, "soundness": {"value": 2}, "presentation": {"value": 1}, "contribution": {"value": 1}, "strengths": {"value": "The focus of this paper, \"Approximate Nearest Neighbor Search Considering Timestamps,\" is important and convincing. Timestamped data are ubiquitous, yet most existing approximate nearest neighbor search methods do not provide explicit solutions for handling them. There is a strong demand for data structures that consider timestamps. The formulation presented in Sec. 1, \"Our Approach,\" for expressing this problem is well-reasoned and logically consistent."}, "weaknesses": {"value": "This paper addresses an interesting research topic. However, there are several points where the descriptions are insufficient, as detailed below. In its current form, I do not believe the manuscript is ready for acceptance.\n\n## Complexity of Explanation\n\nAbove all, the proposed method is complex and difficult to understand. The authors make a sincere effort to explain the method clearly through pseudocode (Algorithms 1, 2, and 3) and simple figures (Figs. 1, 2, and 3), but even so, the method remains difficult to grasp. Due to this complexity, it becomes unclear whether the proposed approach is indeed effective.\n\n## Deficiencies in Notation\n\nRelated to the above, there is significant room for improvement in the paper's notation.\n\n- First, there are too many subscripted variables, which significantly reduces readability. For example, `v_k_t_c` in Algorithm 1, line 8, has three levels of subscripts and is very hard to interpret.\n- It is recommended to use Roman type for ordinary English words. For instance, in Algorithm 1, line 17, the notation `v_min_t_c` would be more readable if written as `v_\\mathrm{min}`.\n- In the pseudocode, the style of description should be unified, whether to use mathematical notation or pseudocode-style notation. For example, the `=` symbol is used for assignment in Algorithm 1 (e.g., line 5), but for equality in Algorithm 2 (e.g., line 6). This inconsistency can be considered an error.\n- In Figure 2, both timestamps and node indices are represented by small integers, which is confusing. It would be clearer to use a different font or distinct numerical ranges for these two types of values.\n\n## Lack of Baselines\n\nThe paper lacks sufficient baselines for comparison. The only comparison is with HNSW enhanced by simple pre- and post-processing, but it is obvious that such a setup would perform poorly under extreme parameter configurations. It would be preferable to include comparisons with other related methods mentioned in Section 5.\n\n## No Description of Memory Consumption\n\nThe paper does not provide a concrete discussion of memory consumption. Data structures for neighbor search must be evaluated in terms of the trade-offs among accuracy, runtime, and memory. Without memory usage analysis, the discussion remains incomplete (for instance, if unlimited memory were available, entirely different and more effective methods might be feasible). Specifically, the structure `active(v)` likely maintains a set (e.g., `std::set`) for each node, which requires memory space. But such considerations are not discussed in the paper."}, "questions": {"value": "In Algorithm 1, the output is listed as only the updated index $G'$; however, at a minimum, a data structure such as `active(v)` should also be required. How many such hidden data structures are there?"}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 5}, "code_of_conduct": {"value": "Yes"}}, "id": "OuHDLJl8Gk", "forum": "nadglckd3z", "replyto": "nadglckd3z", "signatures": ["ICLR.cc/2026/Conference/Submission13400/Reviewer_8zfo"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission13400/Reviewer_8zfo"], "number": 3, "invitations": ["ICLR.cc/2026/Conference/Submission13400/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762109419711, "cdate": 1762109419711, "tmdate": 1762924034073, "mdate": 1762924034073, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}, {"content": {"summary": {"value": "The authors present a TiGER model to support temporal filtering during search while enabling dynamic updates. Experimental study shows that TiGER achieves 5x improvement over HNSW (pre) and HNSW (post)."}, "soundness": {"value": 2}, "presentation": {"value": 3}, "contribution": {"value": 1}, "strengths": {"value": "Strength\n\nS1. This paper is self-contained and easy to follow.\n\nS2. The problem may be interesting for some readers."}, "weaknesses": {"value": "Weakness\n\nW1. Motivation is not clear.\n\nW2. The experimental setup is not convincing.\n\nW3. Novality is not clear.\n\nDetailed comments\n\nD1. This paper proposes a vector retrieval algorithm designed for temporal data to handle dynamic updates. First, are there real-world applications that support this specific scenario? Secondly, in practical applications today, vector datasets often reach billions of entities with substantial daily updates and high dynamism. It remains unclear whether the proposed method can support such a scenario with intense fluctuations.\n\nD2. The paper lacks a theoretical analysis of the method's effectiveness. Merely describing the algorithm's logic and demonstrating its efficacy through experiments is insufficient.\n\nD3. The authors need to explain why HNSW was chosen from the many available ANNS algorithms. Furthermore, comparing only with HNSW is far from sufficient; a comparison with more algorithms is necessary.\n\nD4. To strengthen the validation, the experimental evaluation should be expanded. It would be beneficial to include datasets exhibiting different update patterns (e.g., high-frequency vs. low-frequency) and at least one large-scale (hundreds of millions) dataset. This would more convincingly demonstrate the robustness and scalability of the proposed method."}, "questions": {"value": "Please refer to the weakness part."}, "flag_for_ethics_review": {"value": ["No ethics review needed."]}, "rating": {"value": 2}, "confidence": {"value": 4}, "code_of_conduct": {"value": "Yes"}}, "id": "BEvgi2MAXm", "forum": "nadglckd3z", "replyto": "nadglckd3z", "signatures": ["ICLR.cc/2026/Conference/Submission13400/Reviewer_AWwp"], "nonreaders": [], "readers": ["everyone"], "writers": ["ICLR.cc/2026/Conference", "ICLR.cc/2026/Conference/Submission13400/Reviewer_AWwp"], "number": 4, "invitations": ["ICLR.cc/2026/Conference/Submission13400/-/Official_Review", "ICLR.cc/2026/Conference/-/Edit"], "domain": "ICLR.cc/2026/Conference", "tcdate": 1762242940168, "cdate": 1762242940168, "tmdate": 1762924033439, "mdate": 1762924033439, "parentInvitations": "ICLR.cc/2026/Conference/-/Official_Review", "license": "CC BY 4.0", "version": 2}], "withdrawn": false}